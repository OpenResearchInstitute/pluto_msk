------------------------------------------------------------------------------------------------------
-- K=7 Convolutional Encoder - BRAM Optimized Version
------------------------------------------------------------------------------------------------------
-- Rate 1/2, constraint length K=7
-- Generator polynomials: G1 = 171 octal = 1111001 binary
--                        G2 = 133 octal = 1011011 binary
--
-- RESOURCE OPTIMIZATION:
--   Original version: ~3000 LUTs (bit-level indexing creates massive mux/demux)
--   This version: ~100-200 LUTs (byte-level BRAM addressing)
--
-- TIMING:
--   Original: ~1072 clocks (1 bit/clock encoding only)
--   This version: ~134 (load) + 1072 (encode) + 268 (unload) = ~1474 clocks
--   Still completes in < 25 Âµs at 61.44 MHz, well under frame time
--
-- KEY INSIGHT:
--   BRAM cannot do variable bit-level addressing. The expression:
--     buffer(TOTAL_BITS - 1 - bit_index)  
--   creates a TOTAL_BITS:1 mux in LUTs. Instead, we use byte addressing:
--     ram(byte_index) 
--   which Vivado can implement in BRAM.
------------------------------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY conv_encoder_k7 IS
    GENERIC (
        PAYLOAD_BYTES  : NATURAL := 134;   -- Input size in bytes
        ENCODED_BYTES  : NATURAL := 268    -- Output size in bytes (2x for rate 1/2)
    );
    PORT (
        clk            : IN  std_logic;
        aresetn        : IN  std_logic;
        
        start          : IN  std_logic;
        busy           : OUT std_logic;
        done           : OUT std_logic;
        
        input_buffer   : IN  std_logic_vector(PAYLOAD_BYTES*8-1 DOWNTO 0);
        output_buffer  : OUT std_logic_vector(ENCODED_BYTES*8-1 DOWNTO 0)
    );
END ENTITY conv_encoder_k7;

ARCHITECTURE rtl OF conv_encoder_k7 IS

    -- State machine
    TYPE state_t IS (IDLE, LOAD_INPUT, ENCODE, UNLOAD_OUTPUT, COMPLETE);
    SIGNAL state : state_t := IDLE;
    
    -- BRAM for input storage (byte-addressable)
    TYPE input_ram_t IS ARRAY(0 TO PAYLOAD_BYTES-1) OF std_logic_vector(7 DOWNTO 0);
    SIGNAL input_ram : input_ram_t;
    
    -- BRAM for output storage (byte-addressable)  
    TYPE output_ram_t IS ARRAY(0 TO ENCODED_BYTES-1) OF std_logic_vector(7 DOWNTO 0);
    SIGNAL output_ram : output_ram_t;
    
    -- Force BRAM inference
    ATTRIBUTE ram_style : STRING;
    ATTRIBUTE ram_style OF input_ram : SIGNAL IS "block";
    ATTRIBUTE ram_style OF output_ram : SIGNAL IS "block";
    
    -- General byte counter (reused across states)
    SIGNAL byte_cnt : NATURAL RANGE 0 TO ENCODED_BYTES;
    
    -- Encoding state
    SIGNAL in_byte_addr : NATURAL RANGE 0 TO PAYLOAD_BYTES-1;
    SIGNAL in_bit_pos   : NATURAL RANGE 0 TO 7;  -- Which bit within current input byte
    SIGNAL total_in_bits: NATURAL RANGE 0 TO PAYLOAD_BYTES*8;
    
    -- Current input byte register
    SIGNAL in_byte_reg : std_logic_vector(7 DOWNTO 0);
    
    -- Output accumulator (shift register, fills LSB-first then we reverse on write)
    SIGNAL out_accum    : std_logic_vector(7 DOWNTO 0);
    SIGNAL out_bit_cnt  : NATURAL RANGE 0 TO 7;  -- 0-7, wraps after writing byte
    SIGNAL out_byte_addr: NATURAL RANGE 0 TO ENCODED_BYTES-1;
    
    -- Encoder shift register (6 bits of history for K=7)
    SIGNAL enc_sr : std_logic_vector(5 DOWNTO 0);
    
    -- Parallel output buffer
    SIGNAL out_buf : std_logic_vector(ENCODED_BYTES*8-1 DOWNTO 0);

BEGIN

    PROCESS(clk, aresetn)
        VARIABLE curr_bit : std_logic;
        VARIABLE g1, g2 : std_logic;
        VARIABLE enc_state : std_logic_vector(6 DOWNTO 0);
        VARIABLE new_accum : std_logic_vector(7 DOWNTO 0);
    BEGIN
        IF aresetn = '0' THEN
            state <= IDLE;
            busy <= '0';
            done <= '0';
            byte_cnt <= 0;
            in_byte_addr <= 0;
            in_bit_pos <= 0;
            total_in_bits <= 0;
            in_byte_reg <= (OTHERS => '0');
            out_accum <= (OTHERS => '0');
            out_bit_cnt <= 0;
            out_byte_addr <= 0;
            enc_sr <= (OTHERS => '0');
            out_buf <= (OTHERS => '0');
            
        ELSIF rising_edge(clk) THEN
            done <= '0';
            
            CASE state IS
            
                -------------------------------------------------------------------------
                -- IDLE: Wait for start signal
                -------------------------------------------------------------------------
                WHEN IDLE =>
                    busy <= '0';
                    IF start = '1' THEN
                        state <= LOAD_INPUT;
                        busy <= '1';
                        byte_cnt <= 0;
                    END IF;
                
                -------------------------------------------------------------------------
                -- LOAD_INPUT: Sequential load from parallel input into BRAM
                -- This takes PAYLOAD_BYTES cycles but eliminates the giant mux
                -------------------------------------------------------------------------
                WHEN LOAD_INPUT =>
                    IF byte_cnt < PAYLOAD_BYTES THEN
                        -- Byte 0 of input_buffer is MSB (bits 1071:1064)
                        input_ram(byte_cnt) <= input_buffer(
                            (PAYLOAD_BYTES - byte_cnt) * 8 - 1 DOWNTO 
                            (PAYLOAD_BYTES - byte_cnt - 1) * 8
                        );
                        byte_cnt <= byte_cnt + 1;
                    ELSE
                        -- Done loading, initialize encoding
                        state <= ENCODE;
                        in_byte_addr <= 0;
                        in_bit_pos <= 0;
                        total_in_bits <= 0;
                        out_accum <= (OTHERS => '0');
                        out_bit_cnt <= 0;
                        out_byte_addr <= 0;
                        enc_sr <= (OTHERS => '0');
                        -- Pre-load first byte
                        in_byte_reg <= input_ram(0);
                    END IF;
                
                -------------------------------------------------------------------------
                -- ENCODE: Process one input bit per clock, output two encoded bits
                -- Every 4 input bits produces 8 output bits (one byte)
                -------------------------------------------------------------------------
                WHEN ENCODE =>
                    IF total_in_bits < PAYLOAD_BYTES * 8 THEN
                        -- Extract current input bit (MSB first within each byte)
                        curr_bit := in_byte_reg(7 - in_bit_pos);
                        
                        -- Compute encoded outputs
                        enc_state := curr_bit & enc_sr;
                        -- G1 polynomial: 1111001 (octal 171)
                        g1 := enc_state(6) XOR enc_state(5) XOR enc_state(4) XOR 
                              enc_state(3) XOR enc_state(0);
                        -- G2 polynomial: 1011011 (octal 133)  
                        g2 := enc_state(6) XOR enc_state(4) XOR enc_state(3) XOR 
                              enc_state(1) XOR enc_state(0);
                        
                        -- Update encoder shift register
                        enc_sr <= enc_sr(4 DOWNTO 0) & curr_bit;
                        
                        -- Accumulate output bits (MSB first: g1 then g2)
                        -- Shift left by 2, insert g1 and g2 at LSBs
                        new_accum := out_accum(5 DOWNTO 0) & g1 & g2;
                        out_accum <= new_accum;
                        
                        -- Every 4 input bits (8 output bits), write to output BRAM
                        IF out_bit_cnt = 6 THEN  -- After this we'll have 8 bits
                            output_ram(out_byte_addr) <= new_accum;
                            out_byte_addr <= out_byte_addr + 1;
                            out_bit_cnt <= 0;
                            out_accum <= (OTHERS => '0');
                        ELSE
                            out_bit_cnt <= out_bit_cnt + 2;
                        END IF;
                        
                        -- Advance to next input bit
                        IF in_bit_pos = 7 THEN
                            -- Move to next input byte
                            in_bit_pos <= 0;
                            IF in_byte_addr < PAYLOAD_BYTES - 1 THEN
                                in_byte_addr <= in_byte_addr + 1;
                                in_byte_reg <= input_ram(in_byte_addr + 1);
                            END IF;
                        ELSE
                            in_bit_pos <= in_bit_pos + 1;
                        END IF;
                        
                        total_in_bits <= total_in_bits + 1;
                        
                    ELSE
                        -- Encoding complete
                        state <= UNLOAD_OUTPUT;
                        byte_cnt <= 0;
                    END IF;
                
                -------------------------------------------------------------------------
                -- UNLOAD_OUTPUT: Sequential read from BRAM to parallel output
                -------------------------------------------------------------------------
                WHEN UNLOAD_OUTPUT =>
                    IF byte_cnt < ENCODED_BYTES THEN
                        out_buf(
                            (ENCODED_BYTES - byte_cnt) * 8 - 1 DOWNTO 
                            (ENCODED_BYTES - byte_cnt - 1) * 8
                        ) <= output_ram(byte_cnt);
                        byte_cnt <= byte_cnt + 1;
                    ELSE
                        state <= COMPLETE;
                    END IF;
                
                -------------------------------------------------------------------------
                -- COMPLETE: Assert done for one cycle
                -------------------------------------------------------------------------
                WHEN COMPLETE =>
                    done <= '1';
                    busy <= '0';
                    state <= IDLE;
                    
            END CASE;
        END IF;
    END PROCESS;
    
    output_buffer <= out_buf;

END ARCHITECTURE rtl;
