-- Generated by PeakRDL-regblock-vhdl - A free and open-source VHDL generator
--  https://github.com/SystemRDL/PeakRDL-regblock-vhdl
library ieee;
context ieee.ieee_std_context;
use ieee.fixed_pkg.all;

use work.msk_top_regs_pkg.all;
use work.axi4lite_intf_pkg.all;
use work.reg_utils.all;

entity msk_top_regs is
    port (
        clk : in std_logic;
        rst : in std_logic;

        s_axil_i : in axi4lite_slave_in_intf(
            AWADDR(7 downto 0),
            WDATA(31 downto 0),
            WSTRB(3 downto 0),
            ARADDR(7 downto 0)
        );
        s_axil_o : out axi4lite_slave_out_intf(
            RDATA(31 downto 0)
        );

        hwif_in : in msk_top_regs_in_t;
        hwif_out : out msk_top_regs_out_t
    );
end entity msk_top_regs;

architecture rtl of msk_top_regs is
    ----------------------------------------------------------------------------
    -- CPU Bus interface signals
    ----------------------------------------------------------------------------
    signal cpuif_req : std_logic;
    signal cpuif_req_is_wr : std_logic;
    signal cpuif_addr : std_logic_vector(7 downto 0);
    signal cpuif_wr_data : std_logic_vector(31 downto 0);
    signal cpuif_wr_biten : std_logic_vector(31 downto 0);
    signal cpuif_req_stall_wr : std_logic;
    signal cpuif_req_stall_rd : std_logic;

    signal cpuif_rd_ack : std_logic;
    signal cpuif_rd_err : std_logic;
    signal cpuif_rd_data : std_logic_vector(31 downto 0);

    signal cpuif_wr_ack : std_logic;
    signal cpuif_wr_err : std_logic;

    signal cpuif_req_masked : std_logic;

    signal axil_n_in_flight : unsigned(1 downto 0);
    signal axil_prev_was_rd : std_logic;
    signal axil_arvalid : std_logic;
    signal axil_araddr : std_logic_vector(7 downto 0);
    signal axil_ar_accept : std_logic;
    signal axil_awvalid : std_logic;
    signal axil_awaddr : std_logic_vector(7 downto 0);
    signal axil_wvalid : std_logic;
    signal axil_wdata : std_logic_vector(31 downto 0);
    signal axil_wstrb : std_logic_vector(3 downto 0);
    signal axil_aw_accept : std_logic;
    signal axil_resp_acked : std_logic;
    type axil_resp_buffer_t is record
        is_wr : std_logic;
        err : std_logic;
        rdata : std_logic_vector(31 downto 0);
    end record axil_resp_buffer_t;
    type axil_resp_buffer_array_t is array (integer range <>) of axil_resp_buffer_t;
    signal axil_resp_buffer : axil_resp_buffer_array_t(1 downto 0);
    signal axil_resp_wptr : unsigned(1 downto 0);
    signal axil_resp_rptr : unsigned(1 downto 0);

    ----------------------------------------------------------------------------
    -- Address Decode Signals
    ----------------------------------------------------------------------------
    type decoded_reg_strb_t is record
        Hash_ID_Low : std_logic;
        Hash_ID_High : std_logic;
        MSK_Init : std_logic;
        MSK_Control : std_logic;
        MSK_Status : std_logic;
        Tx_Bit_Count : std_logic;
        Tx_Enable_Count : std_logic;
        Fb_FreqWord : std_logic;
        TX_F1_FreqWord : std_logic;
        TX_F2_FreqWord : std_logic;
        RX_F1_FreqWord : std_logic;
        RX_F2_FreqWord : std_logic;
        LPF_Config_0 : std_logic;
        LPF_Config_1 : std_logic;
        Tx_Data_Width : std_logic;
        Rx_Data_Width : std_logic;
        PRBS_Control : std_logic;
        PRBS_Initial_State : std_logic;
        PRBS_Polynomial : std_logic;
        PRBS_Error_Mask : std_logic;
        PRBS_Bit_Count : std_logic;
        PRBS_Error_Count : std_logic;
        LPF_Accum_F1 : std_logic;
        LPF_Accum_F2 : std_logic;
        axis_xfer_count : std_logic;
        Rx_Sample_Discard : std_logic;
        LPF_Config_2 : std_logic;
        f1_nco_adjust : std_logic;
        f2_nco_adjust : std_logic;
        f1_error : std_logic;
        f2_error : std_logic;
        Tx_Sync_Ctrl : std_logic;
        Tx_Sync_Cnt : std_logic;
        lowpass_ema_alpha1 : std_logic;
        lowpass_ema_alpha2 : std_logic;
        rx_power : std_logic;
    end record;
    signal decoded_reg_strb : decoded_reg_strb_t;
    signal decoded_req : std_logic;
    signal decoded_req_is_wr : std_logic;
    signal decoded_wr_data : std_logic_vector(31 downto 0);
    signal decoded_wr_biten : std_logic_vector(31 downto 0);

    ----------------------------------------------------------------------------
    -- Field Logic Signals
    ----------------------------------------------------------------------------
    -- Field Combinational Signals
    type \msk_top_regs.MSK_Init.txrxinit_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.MSK_Init.txinit_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.MSK_Init.rxinit_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.MSK_Init_combo_t\ is record
        txrxinit : \msk_top_regs.MSK_Init.txrxinit_combo_t\;
        txinit : \msk_top_regs.MSK_Init.txinit_combo_t\;
        rxinit : \msk_top_regs.MSK_Init.rxinit_combo_t\;
    end record;

    type \msk_top_regs.MSK_Control.ptt_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.MSK_Control.loopback_ena_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.MSK_Control.rx_invert_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.MSK_Control.clear_counts_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.MSK_Control.diff_encoder_loopback_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.MSK_Control_combo_t\ is record
        ptt : \msk_top_regs.MSK_Control.ptt_combo_t\;
        loopback_ena : \msk_top_regs.MSK_Control.loopback_ena_combo_t\;
        rx_invert : \msk_top_regs.MSK_Control.rx_invert_combo_t\;
        clear_counts : \msk_top_regs.MSK_Control.clear_counts_combo_t\;
        diff_encoder_loopback : \msk_top_regs.MSK_Control.diff_encoder_loopback_combo_t\;
    end record;

    type \msk_top_regs.Fb_FreqWord.config_data_combo_t\ is record
        next_q : std_logic_vector(31 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.Fb_FreqWord_combo_t\ is record
        config_data : \msk_top_regs.Fb_FreqWord.config_data_combo_t\;
    end record;

    type \msk_top_regs.TX_F1_FreqWord.config_data_combo_t\ is record
        next_q : std_logic_vector(31 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.TX_F1_FreqWord_combo_t\ is record
        config_data : \msk_top_regs.TX_F1_FreqWord.config_data_combo_t\;
    end record;

    type \msk_top_regs.TX_F2_FreqWord.config_data_combo_t\ is record
        next_q : std_logic_vector(31 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.TX_F2_FreqWord_combo_t\ is record
        config_data : \msk_top_regs.TX_F2_FreqWord.config_data_combo_t\;
    end record;

    type \msk_top_regs.RX_F1_FreqWord.config_data_combo_t\ is record
        next_q : std_logic_vector(31 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.RX_F1_FreqWord_combo_t\ is record
        config_data : \msk_top_regs.RX_F1_FreqWord.config_data_combo_t\;
    end record;

    type \msk_top_regs.RX_F2_FreqWord.config_data_combo_t\ is record
        next_q : std_logic_vector(31 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.RX_F2_FreqWord_combo_t\ is record
        config_data : \msk_top_regs.RX_F2_FreqWord.config_data_combo_t\;
    end record;

    type \msk_top_regs.LPF_Config_0.lpf_freeze_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.LPF_Config_0.lpf_zero_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.LPF_Config_0.prbs_reserved_combo_t\ is record
        next_q : std_logic_vector(5 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.LPF_Config_0.lpf_alpha_combo_t\ is record
        next_q : std_logic_vector(23 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.LPF_Config_0_combo_t\ is record
        lpf_freeze : \msk_top_regs.LPF_Config_0.lpf_freeze_combo_t\;
        lpf_zero : \msk_top_regs.LPF_Config_0.lpf_zero_combo_t\;
        prbs_reserved : \msk_top_regs.LPF_Config_0.prbs_reserved_combo_t\;
        lpf_alpha : \msk_top_regs.LPF_Config_0.lpf_alpha_combo_t\;
    end record;

    type \msk_top_regs.LPF_Config_1.i_gain_combo_t\ is record
        next_q : std_logic_vector(23 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.LPF_Config_1.i_shift_combo_t\ is record
        next_q : std_logic_vector(7 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.LPF_Config_1_combo_t\ is record
        i_gain : \msk_top_regs.LPF_Config_1.i_gain_combo_t\;
        i_shift : \msk_top_regs.LPF_Config_1.i_shift_combo_t\;
    end record;

    type \msk_top_regs.Tx_Data_Width.data_width_combo_t\ is record
        next_q : std_logic_vector(7 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.Tx_Data_Width_combo_t\ is record
        data_width : \msk_top_regs.Tx_Data_Width.data_width_combo_t\;
    end record;

    type \msk_top_regs.Rx_Data_Width.data_width_combo_t\ is record
        next_q : std_logic_vector(7 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.Rx_Data_Width_combo_t\ is record
        data_width : \msk_top_regs.Rx_Data_Width.data_width_combo_t\;
    end record;

    type \msk_top_regs.PRBS_Control.prbs_sel_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.PRBS_Control.prbs_error_insert_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.PRBS_Control.prbs_clear_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.PRBS_Control.prbs_manual_sync_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.PRBS_Control.prbs_reserved_combo_t\ is record
        next_q : std_logic_vector(11 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.PRBS_Control.prbs_sync_threshold_combo_t\ is record
        next_q : std_logic_vector(15 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.PRBS_Control_combo_t\ is record
        prbs_sel : \msk_top_regs.PRBS_Control.prbs_sel_combo_t\;
        prbs_error_insert : \msk_top_regs.PRBS_Control.prbs_error_insert_combo_t\;
        prbs_clear : \msk_top_regs.PRBS_Control.prbs_clear_combo_t\;
        prbs_manual_sync : \msk_top_regs.PRBS_Control.prbs_manual_sync_combo_t\;
        prbs_reserved : \msk_top_regs.PRBS_Control.prbs_reserved_combo_t\;
        prbs_sync_threshold : \msk_top_regs.PRBS_Control.prbs_sync_threshold_combo_t\;
    end record;

    type \msk_top_regs.PRBS_Initial_State.config_data_combo_t\ is record
        next_q : std_logic_vector(31 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.PRBS_Initial_State_combo_t\ is record
        config_data : \msk_top_regs.PRBS_Initial_State.config_data_combo_t\;
    end record;

    type \msk_top_regs.PRBS_Polynomial.config_data_combo_t\ is record
        next_q : std_logic_vector(31 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.PRBS_Polynomial_combo_t\ is record
        config_data : \msk_top_regs.PRBS_Polynomial.config_data_combo_t\;
    end record;

    type \msk_top_regs.PRBS_Error_Mask.config_data_combo_t\ is record
        next_q : std_logic_vector(31 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.PRBS_Error_Mask_combo_t\ is record
        config_data : \msk_top_regs.PRBS_Error_Mask.config_data_combo_t\;
    end record;

    type \msk_top_regs.Rx_Sample_Discard.rx_sample_discard_combo_t\ is record
        next_q : std_logic_vector(7 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.Rx_Sample_Discard.rx_nco_discard_combo_t\ is record
        next_q : std_logic_vector(7 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.Rx_Sample_Discard_combo_t\ is record
        rx_sample_discard : \msk_top_regs.Rx_Sample_Discard.rx_sample_discard_combo_t\;
        rx_nco_discard : \msk_top_regs.Rx_Sample_Discard.rx_nco_discard_combo_t\;
    end record;

    type \msk_top_regs.LPF_Config_2.p_gain_combo_t\ is record
        next_q : std_logic_vector(23 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.LPF_Config_2.p_shift_combo_t\ is record
        next_q : std_logic_vector(7 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.LPF_Config_2_combo_t\ is record
        p_gain : \msk_top_regs.LPF_Config_2.p_gain_combo_t\;
        p_shift : \msk_top_regs.LPF_Config_2.p_shift_combo_t\;
    end record;

    type \msk_top_regs.Tx_Sync_Ctrl.tx_sync_ena_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.Tx_Sync_Ctrl.tx_sync_force_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.Tx_Sync_Ctrl.tx_sync_f1_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.Tx_Sync_Ctrl.tx_sync_f2_combo_t\ is record
        next_q : std_logic;
        load_next : std_logic;
    end record;

    type \msk_top_regs.Tx_Sync_Ctrl_combo_t\ is record
        tx_sync_ena : \msk_top_regs.Tx_Sync_Ctrl.tx_sync_ena_combo_t\;
        tx_sync_force : \msk_top_regs.Tx_Sync_Ctrl.tx_sync_force_combo_t\;
        tx_sync_f1 : \msk_top_regs.Tx_Sync_Ctrl.tx_sync_f1_combo_t\;
        tx_sync_f2 : \msk_top_regs.Tx_Sync_Ctrl.tx_sync_f2_combo_t\;
    end record;

    type \msk_top_regs.Tx_Sync_Cnt.tx_sync_cnt_combo_t\ is record
        next_q : std_logic_vector(23 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.Tx_Sync_Cnt_combo_t\ is record
        tx_sync_cnt : \msk_top_regs.Tx_Sync_Cnt.tx_sync_cnt_combo_t\;
    end record;

    type \msk_top_regs.lowpass_ema_alpha1.alpha_combo_t\ is record
        next_q : std_logic_vector(17 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.lowpass_ema_alpha1_combo_t\ is record
        alpha : \msk_top_regs.lowpass_ema_alpha1.alpha_combo_t\;
    end record;

    type \msk_top_regs.lowpass_ema_alpha2.alpha_combo_t\ is record
        next_q : std_logic_vector(17 downto 0);
        load_next : std_logic;
    end record;

    type \msk_top_regs.lowpass_ema_alpha2_combo_t\ is record
        alpha : \msk_top_regs.lowpass_ema_alpha2.alpha_combo_t\;
    end record;

    type field_combo_t is record
        MSK_Init : \msk_top_regs.MSK_Init_combo_t\;
        MSK_Control : \msk_top_regs.MSK_Control_combo_t\;
        Fb_FreqWord : \msk_top_regs.Fb_FreqWord_combo_t\;
        TX_F1_FreqWord : \msk_top_regs.TX_F1_FreqWord_combo_t\;
        TX_F2_FreqWord : \msk_top_regs.TX_F2_FreqWord_combo_t\;
        RX_F1_FreqWord : \msk_top_regs.RX_F1_FreqWord_combo_t\;
        RX_F2_FreqWord : \msk_top_regs.RX_F2_FreqWord_combo_t\;
        LPF_Config_0 : \msk_top_regs.LPF_Config_0_combo_t\;
        LPF_Config_1 : \msk_top_regs.LPF_Config_1_combo_t\;
        Tx_Data_Width : \msk_top_regs.Tx_Data_Width_combo_t\;
        Rx_Data_Width : \msk_top_regs.Rx_Data_Width_combo_t\;
        PRBS_Control : \msk_top_regs.PRBS_Control_combo_t\;
        PRBS_Initial_State : \msk_top_regs.PRBS_Initial_State_combo_t\;
        PRBS_Polynomial : \msk_top_regs.PRBS_Polynomial_combo_t\;
        PRBS_Error_Mask : \msk_top_regs.PRBS_Error_Mask_combo_t\;
        Rx_Sample_Discard : \msk_top_regs.Rx_Sample_Discard_combo_t\;
        LPF_Config_2 : \msk_top_regs.LPF_Config_2_combo_t\;
        Tx_Sync_Ctrl : \msk_top_regs.Tx_Sync_Ctrl_combo_t\;
        Tx_Sync_Cnt : \msk_top_regs.Tx_Sync_Cnt_combo_t\;
        lowpass_ema_alpha1 : \msk_top_regs.lowpass_ema_alpha1_combo_t\;
        lowpass_ema_alpha2 : \msk_top_regs.lowpass_ema_alpha2_combo_t\;
    end record;
    signal field_combo : field_combo_t;

    -- Field Storage Signals
    type \msk_top_regs.MSK_Init.txrxinit_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.MSK_Init.txinit_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.MSK_Init.rxinit_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.MSK_Init_storage_t\ is record
        txrxinit : \msk_top_regs.MSK_Init.txrxinit_storage_t\;
        txinit : \msk_top_regs.MSK_Init.txinit_storage_t\;
        rxinit : \msk_top_regs.MSK_Init.rxinit_storage_t\;
    end record;

    type \msk_top_regs.MSK_Control.ptt_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.MSK_Control.loopback_ena_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.MSK_Control.rx_invert_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.MSK_Control.clear_counts_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.MSK_Control.diff_encoder_loopback_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.MSK_Control_storage_t\ is record
        ptt : \msk_top_regs.MSK_Control.ptt_storage_t\;
        loopback_ena : \msk_top_regs.MSK_Control.loopback_ena_storage_t\;
        rx_invert : \msk_top_regs.MSK_Control.rx_invert_storage_t\;
        clear_counts : \msk_top_regs.MSK_Control.clear_counts_storage_t\;
        diff_encoder_loopback : \msk_top_regs.MSK_Control.diff_encoder_loopback_storage_t\;
    end record;

    type \msk_top_regs.Fb_FreqWord.config_data_storage_t\ is record
        value : std_logic_vector(31 downto 0);
    end record;

    type \msk_top_regs.Fb_FreqWord_storage_t\ is record
        config_data : \msk_top_regs.Fb_FreqWord.config_data_storage_t\;
    end record;

    type \msk_top_regs.TX_F1_FreqWord.config_data_storage_t\ is record
        value : std_logic_vector(31 downto 0);
    end record;

    type \msk_top_regs.TX_F1_FreqWord_storage_t\ is record
        config_data : \msk_top_regs.TX_F1_FreqWord.config_data_storage_t\;
    end record;

    type \msk_top_regs.TX_F2_FreqWord.config_data_storage_t\ is record
        value : std_logic_vector(31 downto 0);
    end record;

    type \msk_top_regs.TX_F2_FreqWord_storage_t\ is record
        config_data : \msk_top_regs.TX_F2_FreqWord.config_data_storage_t\;
    end record;

    type \msk_top_regs.RX_F1_FreqWord.config_data_storage_t\ is record
        value : std_logic_vector(31 downto 0);
    end record;

    type \msk_top_regs.RX_F1_FreqWord_storage_t\ is record
        config_data : \msk_top_regs.RX_F1_FreqWord.config_data_storage_t\;
    end record;

    type \msk_top_regs.RX_F2_FreqWord.config_data_storage_t\ is record
        value : std_logic_vector(31 downto 0);
    end record;

    type \msk_top_regs.RX_F2_FreqWord_storage_t\ is record
        config_data : \msk_top_regs.RX_F2_FreqWord.config_data_storage_t\;
    end record;

    type \msk_top_regs.LPF_Config_0.lpf_freeze_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.LPF_Config_0.lpf_zero_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.LPF_Config_0.prbs_reserved_storage_t\ is record
        value : std_logic_vector(5 downto 0);
    end record;

    type \msk_top_regs.LPF_Config_0.lpf_alpha_storage_t\ is record
        value : std_logic_vector(23 downto 0);
    end record;

    type \msk_top_regs.LPF_Config_0_storage_t\ is record
        lpf_freeze : \msk_top_regs.LPF_Config_0.lpf_freeze_storage_t\;
        lpf_zero : \msk_top_regs.LPF_Config_0.lpf_zero_storage_t\;
        prbs_reserved : \msk_top_regs.LPF_Config_0.prbs_reserved_storage_t\;
        lpf_alpha : \msk_top_regs.LPF_Config_0.lpf_alpha_storage_t\;
    end record;

    type \msk_top_regs.LPF_Config_1.i_gain_storage_t\ is record
        value : std_logic_vector(23 downto 0);
    end record;

    type \msk_top_regs.LPF_Config_1.i_shift_storage_t\ is record
        value : std_logic_vector(7 downto 0);
    end record;

    type \msk_top_regs.LPF_Config_1_storage_t\ is record
        i_gain : \msk_top_regs.LPF_Config_1.i_gain_storage_t\;
        i_shift : \msk_top_regs.LPF_Config_1.i_shift_storage_t\;
    end record;

    type \msk_top_regs.Tx_Data_Width.data_width_storage_t\ is record
        value : std_logic_vector(7 downto 0);
    end record;

    type \msk_top_regs.Tx_Data_Width_storage_t\ is record
        data_width : \msk_top_regs.Tx_Data_Width.data_width_storage_t\;
    end record;

    type \msk_top_regs.Rx_Data_Width.data_width_storage_t\ is record
        value : std_logic_vector(7 downto 0);
    end record;

    type \msk_top_regs.Rx_Data_Width_storage_t\ is record
        data_width : \msk_top_regs.Rx_Data_Width.data_width_storage_t\;
    end record;

    type \msk_top_regs.PRBS_Control.prbs_sel_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.PRBS_Control.prbs_error_insert_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.PRBS_Control.prbs_clear_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.PRBS_Control.prbs_manual_sync_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.PRBS_Control.prbs_reserved_storage_t\ is record
        value : std_logic_vector(11 downto 0);
    end record;

    type \msk_top_regs.PRBS_Control.prbs_sync_threshold_storage_t\ is record
        value : std_logic_vector(15 downto 0);
    end record;

    type \msk_top_regs.PRBS_Control_storage_t\ is record
        prbs_sel : \msk_top_regs.PRBS_Control.prbs_sel_storage_t\;
        prbs_error_insert : \msk_top_regs.PRBS_Control.prbs_error_insert_storage_t\;
        prbs_clear : \msk_top_regs.PRBS_Control.prbs_clear_storage_t\;
        prbs_manual_sync : \msk_top_regs.PRBS_Control.prbs_manual_sync_storage_t\;
        prbs_reserved : \msk_top_regs.PRBS_Control.prbs_reserved_storage_t\;
        prbs_sync_threshold : \msk_top_regs.PRBS_Control.prbs_sync_threshold_storage_t\;
    end record;

    type \msk_top_regs.PRBS_Initial_State.config_data_storage_t\ is record
        value : std_logic_vector(31 downto 0);
    end record;

    type \msk_top_regs.PRBS_Initial_State_storage_t\ is record
        config_data : \msk_top_regs.PRBS_Initial_State.config_data_storage_t\;
    end record;

    type \msk_top_regs.PRBS_Polynomial.config_data_storage_t\ is record
        value : std_logic_vector(31 downto 0);
    end record;

    type \msk_top_regs.PRBS_Polynomial_storage_t\ is record
        config_data : \msk_top_regs.PRBS_Polynomial.config_data_storage_t\;
    end record;

    type \msk_top_regs.PRBS_Error_Mask.config_data_storage_t\ is record
        value : std_logic_vector(31 downto 0);
    end record;

    type \msk_top_regs.PRBS_Error_Mask_storage_t\ is record
        config_data : \msk_top_regs.PRBS_Error_Mask.config_data_storage_t\;
    end record;

    type \msk_top_regs.Rx_Sample_Discard.rx_sample_discard_storage_t\ is record
        value : std_logic_vector(7 downto 0);
    end record;

    type \msk_top_regs.Rx_Sample_Discard.rx_nco_discard_storage_t\ is record
        value : std_logic_vector(7 downto 0);
    end record;

    type \msk_top_regs.Rx_Sample_Discard_storage_t\ is record
        rx_sample_discard : \msk_top_regs.Rx_Sample_Discard.rx_sample_discard_storage_t\;
        rx_nco_discard : \msk_top_regs.Rx_Sample_Discard.rx_nco_discard_storage_t\;
    end record;

    type \msk_top_regs.LPF_Config_2.p_gain_storage_t\ is record
        value : std_logic_vector(23 downto 0);
    end record;

    type \msk_top_regs.LPF_Config_2.p_shift_storage_t\ is record
        value : std_logic_vector(7 downto 0);
    end record;

    type \msk_top_regs.LPF_Config_2_storage_t\ is record
        p_gain : \msk_top_regs.LPF_Config_2.p_gain_storage_t\;
        p_shift : \msk_top_regs.LPF_Config_2.p_shift_storage_t\;
    end record;

    type \msk_top_regs.Tx_Sync_Ctrl.tx_sync_ena_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.Tx_Sync_Ctrl.tx_sync_force_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.Tx_Sync_Ctrl.tx_sync_f1_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.Tx_Sync_Ctrl.tx_sync_f2_storage_t\ is record
        value : std_logic;
    end record;

    type \msk_top_regs.Tx_Sync_Ctrl_storage_t\ is record
        tx_sync_ena : \msk_top_regs.Tx_Sync_Ctrl.tx_sync_ena_storage_t\;
        tx_sync_force : \msk_top_regs.Tx_Sync_Ctrl.tx_sync_force_storage_t\;
        tx_sync_f1 : \msk_top_regs.Tx_Sync_Ctrl.tx_sync_f1_storage_t\;
        tx_sync_f2 : \msk_top_regs.Tx_Sync_Ctrl.tx_sync_f2_storage_t\;
    end record;

    type \msk_top_regs.Tx_Sync_Cnt.tx_sync_cnt_storage_t\ is record
        value : std_logic_vector(23 downto 0);
    end record;

    type \msk_top_regs.Tx_Sync_Cnt_storage_t\ is record
        tx_sync_cnt : \msk_top_regs.Tx_Sync_Cnt.tx_sync_cnt_storage_t\;
    end record;

    type \msk_top_regs.lowpass_ema_alpha1.alpha_storage_t\ is record
        value : std_logic_vector(17 downto 0);
    end record;

    type \msk_top_regs.lowpass_ema_alpha1_storage_t\ is record
        alpha : \msk_top_regs.lowpass_ema_alpha1.alpha_storage_t\;
    end record;

    type \msk_top_regs.lowpass_ema_alpha2.alpha_storage_t\ is record
        value : std_logic_vector(17 downto 0);
    end record;

    type \msk_top_regs.lowpass_ema_alpha2_storage_t\ is record
        alpha : \msk_top_regs.lowpass_ema_alpha2.alpha_storage_t\;
    end record;

    type field_storage_t is record
        MSK_Init : \msk_top_regs.MSK_Init_storage_t\;
        MSK_Control : \msk_top_regs.MSK_Control_storage_t\;
        Fb_FreqWord : \msk_top_regs.Fb_FreqWord_storage_t\;
        TX_F1_FreqWord : \msk_top_regs.TX_F1_FreqWord_storage_t\;
        TX_F2_FreqWord : \msk_top_regs.TX_F2_FreqWord_storage_t\;
        RX_F1_FreqWord : \msk_top_regs.RX_F1_FreqWord_storage_t\;
        RX_F2_FreqWord : \msk_top_regs.RX_F2_FreqWord_storage_t\;
        LPF_Config_0 : \msk_top_regs.LPF_Config_0_storage_t\;
        LPF_Config_1 : \msk_top_regs.LPF_Config_1_storage_t\;
        Tx_Data_Width : \msk_top_regs.Tx_Data_Width_storage_t\;
        Rx_Data_Width : \msk_top_regs.Rx_Data_Width_storage_t\;
        PRBS_Control : \msk_top_regs.PRBS_Control_storage_t\;
        PRBS_Initial_State : \msk_top_regs.PRBS_Initial_State_storage_t\;
        PRBS_Polynomial : \msk_top_regs.PRBS_Polynomial_storage_t\;
        PRBS_Error_Mask : \msk_top_regs.PRBS_Error_Mask_storage_t\;
        Rx_Sample_Discard : \msk_top_regs.Rx_Sample_Discard_storage_t\;
        LPF_Config_2 : \msk_top_regs.LPF_Config_2_storage_t\;
        Tx_Sync_Ctrl : \msk_top_regs.Tx_Sync_Ctrl_storage_t\;
        Tx_Sync_Cnt : \msk_top_regs.Tx_Sync_Cnt_storage_t\;
        lowpass_ema_alpha1 : \msk_top_regs.lowpass_ema_alpha1_storage_t\;
        lowpass_ema_alpha2 : \msk_top_regs.lowpass_ema_alpha2_storage_t\;
    end record;
    signal field_storage : field_storage_t;

    ----------------------------------------------------------------------------
    -- Readback Signals
    ----------------------------------------------------------------------------
    signal readback_err : std_logic;
    signal readback_done : std_logic;
    signal readback_data : std_logic_vector(31 downto 0);
    signal readback_array : std_logic_vector_array1(0 to 35)(31 downto 0);

begin

    ----------------------------------------------------------------------------
    -- CPU Bus interface
    ----------------------------------------------------------------------------
    -- pragma translate_off
    cpuif_generics: process begin
        assert_bad_addr_width: assert s_axil_i.ARADDR'length >= MSK_TOP_REGS_MIN_ADDR_WIDTH
            report "Interface address width of " & integer'image(s_axil_i.ARADDR'length) & " is too small. Shall be at least " & integer'image(MSK_TOP_REGS_MIN_ADDR_WIDTH) & " bits"
            severity failure;
        assert_bad_data_width: assert s_axil_i.WDATA'length = MSK_TOP_REGS_DATA_WIDTH
            report "Interface data width of " & integer'image(s_axil_i.WDATA'length) & " is incorrect. Shall be " & integer'image(MSK_TOP_REGS_DATA_WIDTH) & " bits"
            severity failure;
        wait;
    end process;
    -- pragma translate_on


    -- Max Outstanding Transactions: 2
    -- Transaction request acceptance
    process(clk) begin
        if false then -- async reset
            axil_prev_was_rd <= '0';
            axil_arvalid <= '0';
            axil_araddr <= (others => '0');
            axil_awvalid <= '0';
            axil_awaddr <= (others => '0');
            axil_wvalid <= '0';
            axil_wdata <= (others => '0');
            axil_wstrb <= (others => '0');
            axil_n_in_flight <= (others => '0');
        elsif rising_edge(clk) then
            if rst then -- sync reset
                axil_prev_was_rd <= '0';
                axil_arvalid <= '0';
                axil_araddr <= (others => '0');
                axil_awvalid <= '0';
                axil_awaddr <= (others => '0');
                axil_wvalid <= '0';
                axil_wdata <= (others => '0');
                axil_wstrb <= (others => '0');
                axil_n_in_flight <= (others => '0');
            else
                -- AR* acceptance register
                if axil_ar_accept then
                    axil_prev_was_rd <= '1';
                    axil_arvalid <= '0';
                end if;
                if s_axil_i.ARVALID and s_axil_o.ARREADY then
                    axil_arvalid <= '1';
                    axil_araddr <= s_axil_i.ARADDR;
                end if;

                -- AW* & W* acceptance registers
                if axil_aw_accept  then
                    axil_prev_was_rd <= '0';
                    axil_awvalid <= '0';
                    axil_wvalid <= '0';
                end if;
                if s_axil_i.AWVALID and s_axil_o.AWREADY then
                    axil_awvalid <= '1';
                    axil_awaddr <= s_axil_i.AWADDR;
                end if;
                if s_axil_i.WVALID and s_axil_o.WREADY then
                    axil_wvalid <= '1';
                    axil_wdata <= s_axil_i.WDATA;
                    axil_wstrb <= s_axil_i.WSTRB;
                end if;

                -- Keep track of in-flight transactions
                if (axil_ar_accept or axil_aw_accept) and not axil_resp_acked then
                    axil_n_in_flight <= axil_n_in_flight + 1;
                elsif not (axil_ar_accept or axil_aw_accept) and axil_resp_acked then
                    axil_n_in_flight <= axil_n_in_flight - 1;
                end if;
            end if;
        end if;
    end process;

    process(all) begin
        s_axil_o.ARREADY <= not axil_arvalid or axil_ar_accept;
        s_axil_o.AWREADY <= not axil_awvalid or axil_aw_accept;
        s_axil_o.WREADY <= not axil_wvalid or axil_aw_accept;
    end process;

    -- Request dispatch
    process(all) begin
        cpuif_wr_data <= axil_wdata;
        for i in axil_wstrb'RANGE loop
            cpuif_wr_biten(i*8 + 7 downto i*8) <= (others => axil_wstrb(i));
        end loop;
        cpuif_req <= '0';
        cpuif_req_is_wr <= '0';
        cpuif_addr <= (others => '0');
        axil_ar_accept <= '0';
        axil_aw_accept <= '0';

        if axil_n_in_flight < to_unsigned(2, 2) then
            -- Can safely issue more transactions without overwhelming response buffer
            if axil_arvalid and not axil_prev_was_rd then
                cpuif_req <= '1';
                cpuif_req_is_wr <= '0';
                cpuif_addr <= (7 downto 2 => axil_araddr(7 downto 2), others => '0');
                if not cpuif_req_stall_rd then
                    axil_ar_accept <= '1';
                end if;
            elsif axil_awvalid and axil_wvalid then
                cpuif_req <= '1';
                cpuif_req_is_wr <= '1';
                cpuif_addr <= (7 downto 2 => axil_awaddr(7 downto 2), others => '0');
                if not cpuif_req_stall_wr then
                    axil_aw_accept <= '1';
                end if;
            elsif axil_arvalid then
                cpuif_req <= '1';
                cpuif_req_is_wr <= '0';
                cpuif_addr <= (7 downto 2 => axil_araddr(7 downto 2), others => '0');
                if not cpuif_req_stall_rd then
                    axil_ar_accept <= '1';
                end if;
            end if;
        end if;
    end process;
    -- AXI4-Lite Response Logic
    process(clk) begin
        if false then -- async reset
            for i in axil_resp_buffer'RANGE loop
                axil_resp_buffer(i).is_wr <= '0';
                axil_resp_buffer(i).err <= '0';
                axil_resp_buffer(i).rdata <= (others => '0');
            end loop;
            axil_resp_wptr <= (others => '0');
            axil_resp_rptr <= (others => '0');
        elsif rising_edge(clk) then
            if rst then -- sync reset
                for i in axil_resp_buffer'RANGE loop
                    axil_resp_buffer(i).is_wr <= '0';
                    axil_resp_buffer(i).err <= '0';
                    axil_resp_buffer(i).rdata <= (others => '0');
                end loop;
                axil_resp_wptr <= (others => '0');
                axil_resp_rptr <= (others => '0');
            else
                -- Store responses in buffer until AXI response channel accepts them
                if cpuif_rd_ack or cpuif_wr_ack then
                    if cpuif_rd_ack then
                        axil_resp_buffer(to_integer(axil_resp_wptr(0 downto 0))).is_wr <= '0';
                        axil_resp_buffer(to_integer(axil_resp_wptr(0 downto 0))).err <= cpuif_rd_err;
                        axil_resp_buffer(to_integer(axil_resp_wptr(0 downto 0))).rdata <= cpuif_rd_data;

                    elsif cpuif_wr_ack then
                        axil_resp_buffer(to_integer(axil_resp_wptr(0 downto 0))).is_wr <= '1';
                        axil_resp_buffer(to_integer(axil_resp_wptr(0 downto 0))).err <= cpuif_wr_err;
                    end if;
                    axil_resp_wptr <= axil_resp_wptr + 1;
                end if;

                -- Advance read pointer when acknowledged
                if axil_resp_acked then
                    axil_resp_rptr <= axil_resp_rptr + 1;
                end if;
            end if;
        end if;
    end process;

    process(all) begin
        axil_resp_acked <= '0';
        s_axil_o.BVALID <= '0';
        s_axil_o.RVALID <= '0';
        if axil_resp_rptr /= axil_resp_wptr then
            if axil_resp_buffer(to_integer(axil_resp_rptr(0 downto 0))).is_wr then
                s_axil_o.BVALID <= '1';
                if s_axil_i.BREADY then
                    axil_resp_acked <= '1';
                end if;
            else
                s_axil_o.RVALID <= '1';
                if s_axil_i.RREADY then
                    axil_resp_acked <= '1';
                end if;
            end if;
        end if;

        s_axil_o.RDATA <= axil_resp_buffer(to_integer(axil_resp_rptr(0 downto 0))).rdata;
        if axil_resp_buffer(to_integer(axil_resp_rptr(0 downto 0))).err then
            s_axil_o.BRESP <= "10";
            s_axil_o.RRESP <= "10";
        else
            s_axil_o.BRESP <= "00";
            s_axil_o.RRESP <= "00";
        end if;
    end process;

    -- Read & write latencies are balanced. Stalls not required
    cpuif_req_stall_rd <= '0';
    cpuif_req_stall_wr <= '0';
    cpuif_req_masked <= cpuif_req
                        and not (not cpuif_req_is_wr and cpuif_req_stall_rd)
                        and not (cpuif_req_is_wr and cpuif_req_stall_wr);

    ----------------------------------------------------------------------------
    -- Address Decode
    ----------------------------------------------------------------------------
    process(all)
        -- overload "=" in this scope to avoid lots of type casts
        function "="(L: std_logic_vector; R: integer) return std_logic is
            variable result : std_logic;
        begin
            result := '1' when unsigned(L) = R else '0';
            return result;
        end;
    begin
        decoded_reg_strb.Hash_ID_Low <= cpuif_req_masked and (cpuif_addr = 16#0#);
        decoded_reg_strb.Hash_ID_High <= cpuif_req_masked and (cpuif_addr = 16#4#);
        decoded_reg_strb.MSK_Init <= cpuif_req_masked and (cpuif_addr = 16#8#);
        decoded_reg_strb.MSK_Control <= cpuif_req_masked and (cpuif_addr = 16#C#);
        decoded_reg_strb.MSK_Status <= cpuif_req_masked and (cpuif_addr = 16#10#);
        decoded_reg_strb.Tx_Bit_Count <= cpuif_req_masked and (cpuif_addr = 16#14#);
        decoded_reg_strb.Tx_Enable_Count <= cpuif_req_masked and (cpuif_addr = 16#18#);
        decoded_reg_strb.Fb_FreqWord <= cpuif_req_masked and (cpuif_addr = 16#1C#);
        decoded_reg_strb.TX_F1_FreqWord <= cpuif_req_masked and (cpuif_addr = 16#20#);
        decoded_reg_strb.TX_F2_FreqWord <= cpuif_req_masked and (cpuif_addr = 16#24#);
        decoded_reg_strb.RX_F1_FreqWord <= cpuif_req_masked and (cpuif_addr = 16#28#);
        decoded_reg_strb.RX_F2_FreqWord <= cpuif_req_masked and (cpuif_addr = 16#2C#);
        decoded_reg_strb.LPF_Config_0 <= cpuif_req_masked and (cpuif_addr = 16#30#);
        decoded_reg_strb.LPF_Config_1 <= cpuif_req_masked and (cpuif_addr = 16#34#);
        decoded_reg_strb.Tx_Data_Width <= cpuif_req_masked and (cpuif_addr = 16#38#);
        decoded_reg_strb.Rx_Data_Width <= cpuif_req_masked and (cpuif_addr = 16#3C#);
        decoded_reg_strb.PRBS_Control <= cpuif_req_masked and (cpuif_addr = 16#40#);
        decoded_reg_strb.PRBS_Initial_State <= cpuif_req_masked and (cpuif_addr = 16#44#);
        decoded_reg_strb.PRBS_Polynomial <= cpuif_req_masked and (cpuif_addr = 16#48#);
        decoded_reg_strb.PRBS_Error_Mask <= cpuif_req_masked and (cpuif_addr = 16#4C#);
        decoded_reg_strb.PRBS_Bit_Count <= cpuif_req_masked and (cpuif_addr = 16#50#);
        decoded_reg_strb.PRBS_Error_Count <= cpuif_req_masked and (cpuif_addr = 16#54#);
        decoded_reg_strb.LPF_Accum_F1 <= cpuif_req_masked and (cpuif_addr = 16#58#);
        decoded_reg_strb.LPF_Accum_F2 <= cpuif_req_masked and (cpuif_addr = 16#5C#);
        decoded_reg_strb.axis_xfer_count <= cpuif_req_masked and (cpuif_addr = 16#60#);
        decoded_reg_strb.Rx_Sample_Discard <= cpuif_req_masked and (cpuif_addr = 16#64#);
        decoded_reg_strb.LPF_Config_2 <= cpuif_req_masked and (cpuif_addr = 16#68#);
        decoded_reg_strb.f1_nco_adjust <= cpuif_req_masked and (cpuif_addr = 16#6C#);
        decoded_reg_strb.f2_nco_adjust <= cpuif_req_masked and (cpuif_addr = 16#70#);
        decoded_reg_strb.f1_error <= cpuif_req_masked and (cpuif_addr = 16#74#);
        decoded_reg_strb.f2_error <= cpuif_req_masked and (cpuif_addr = 16#78#);
        decoded_reg_strb.Tx_Sync_Ctrl <= cpuif_req_masked and (cpuif_addr = 16#7C#);
        decoded_reg_strb.Tx_Sync_Cnt <= cpuif_req_masked and (cpuif_addr = 16#80#);
        decoded_reg_strb.lowpass_ema_alpha1 <= cpuif_req_masked and (cpuif_addr = 16#84#);
        decoded_reg_strb.lowpass_ema_alpha2 <= cpuif_req_masked and (cpuif_addr = 16#88#);
        decoded_reg_strb.rx_power <= cpuif_req_masked and (cpuif_addr = 16#8C#);
    end process;

    -- Pass down signals to next stage
    process(all) begin
        decoded_req <= cpuif_req_masked;
        decoded_req_is_wr <= cpuif_req_is_wr;
        decoded_wr_data <= cpuif_wr_data;
        decoded_wr_biten <= cpuif_wr_biten;
    end process;

    ----------------------------------------------------------------------------
    -- Field logic
    ----------------------------------------------------------------------------
    
    -- Field: msk_top_regs.MSK_Init.txrxinit
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.MSK_Init.txrxinit.value;
        load_next_c := '0';
        if decoded_reg_strb.MSK_Init and decoded_req_is_wr then -- SW write
            next_c := (field_storage.MSK_Init.txrxinit.value and not decoded_wr_biten(0)) or (decoded_wr_data(0) and decoded_wr_biten(0));
            load_next_c := '1';
        end if;
        field_combo.MSK_Init.txrxinit.next_q <= next_c;
        field_combo.MSK_Init.txrxinit.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.MSK_Init.txrxinit.value <= '1';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.MSK_Init.txrxinit.value <= '1';
            else
                if field_combo.MSK_Init.txrxinit.load_next then
                    field_storage.MSK_Init.txrxinit.value <= field_combo.MSK_Init.txrxinit.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.MSK_Init.txrxinit.value <= field_storage.MSK_Init.txrxinit.value;

    -- Field: msk_top_regs.MSK_Init.txinit
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.MSK_Init.txinit.value;
        load_next_c := '0';
        if decoded_reg_strb.MSK_Init and decoded_req_is_wr then -- SW write
            next_c := (field_storage.MSK_Init.txinit.value and not decoded_wr_biten(1)) or (decoded_wr_data(1) and decoded_wr_biten(1));
            load_next_c := '1';
        end if;
        field_combo.MSK_Init.txinit.next_q <= next_c;
        field_combo.MSK_Init.txinit.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.MSK_Init.txinit.value <= '1';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.MSK_Init.txinit.value <= '1';
            else
                if field_combo.MSK_Init.txinit.load_next then
                    field_storage.MSK_Init.txinit.value <= field_combo.MSK_Init.txinit.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.MSK_Init.txinit.value <= field_storage.MSK_Init.txinit.value;

    -- Field: msk_top_regs.MSK_Init.rxinit
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.MSK_Init.rxinit.value;
        load_next_c := '0';
        if decoded_reg_strb.MSK_Init and decoded_req_is_wr then -- SW write
            next_c := (field_storage.MSK_Init.rxinit.value and not decoded_wr_biten(2)) or (decoded_wr_data(2) and decoded_wr_biten(2));
            load_next_c := '1';
        end if;
        field_combo.MSK_Init.rxinit.next_q <= next_c;
        field_combo.MSK_Init.rxinit.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.MSK_Init.rxinit.value <= '1';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.MSK_Init.rxinit.value <= '1';
            else
                if field_combo.MSK_Init.rxinit.load_next then
                    field_storage.MSK_Init.rxinit.value <= field_combo.MSK_Init.rxinit.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.MSK_Init.rxinit.value <= field_storage.MSK_Init.rxinit.value;

    -- Field: msk_top_regs.MSK_Control.ptt
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.MSK_Control.ptt.value;
        load_next_c := '0';
        if decoded_reg_strb.MSK_Control and decoded_req_is_wr then -- SW write
            next_c := (field_storage.MSK_Control.ptt.value and not decoded_wr_biten(0)) or (decoded_wr_data(0) and decoded_wr_biten(0));
            load_next_c := '1';
        end if;
        field_combo.MSK_Control.ptt.next_q <= next_c;
        field_combo.MSK_Control.ptt.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.MSK_Control.ptt.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.MSK_Control.ptt.value <= '0';
            else
                if field_combo.MSK_Control.ptt.load_next then
                    field_storage.MSK_Control.ptt.value <= field_combo.MSK_Control.ptt.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.MSK_Control.ptt.value <= field_storage.MSK_Control.ptt.value;

    -- Field: msk_top_regs.MSK_Control.loopback_ena
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.MSK_Control.loopback_ena.value;
        load_next_c := '0';
        if decoded_reg_strb.MSK_Control and decoded_req_is_wr then -- SW write
            next_c := (field_storage.MSK_Control.loopback_ena.value and not decoded_wr_biten(1)) or (decoded_wr_data(1) and decoded_wr_biten(1));
            load_next_c := '1';
        end if;
        field_combo.MSK_Control.loopback_ena.next_q <= next_c;
        field_combo.MSK_Control.loopback_ena.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.MSK_Control.loopback_ena.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.MSK_Control.loopback_ena.value <= '0';
            else
                if field_combo.MSK_Control.loopback_ena.load_next then
                    field_storage.MSK_Control.loopback_ena.value <= field_combo.MSK_Control.loopback_ena.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.MSK_Control.loopback_ena.value <= field_storage.MSK_Control.loopback_ena.value;

    -- Field: msk_top_regs.MSK_Control.rx_invert
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.MSK_Control.rx_invert.value;
        load_next_c := '0';
        if decoded_reg_strb.MSK_Control and decoded_req_is_wr then -- SW write
            next_c := (field_storage.MSK_Control.rx_invert.value and not decoded_wr_biten(2)) or (decoded_wr_data(2) and decoded_wr_biten(2));
            load_next_c := '1';
        end if;
        field_combo.MSK_Control.rx_invert.next_q <= next_c;
        field_combo.MSK_Control.rx_invert.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.MSK_Control.rx_invert.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.MSK_Control.rx_invert.value <= '0';
            else
                if field_combo.MSK_Control.rx_invert.load_next then
                    field_storage.MSK_Control.rx_invert.value <= field_combo.MSK_Control.rx_invert.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.MSK_Control.rx_invert.value <= field_storage.MSK_Control.rx_invert.value;

    -- Field: msk_top_regs.MSK_Control.clear_counts
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.MSK_Control.clear_counts.value;
        load_next_c := '0';
        if decoded_reg_strb.MSK_Control and decoded_req_is_wr then -- SW write
            next_c := (field_storage.MSK_Control.clear_counts.value and not decoded_wr_biten(3)) or (decoded_wr_data(3) and decoded_wr_biten(3));
            load_next_c := '1';
        else -- singlepulse clears back to 0
            next_c := '0';
            load_next_c := '1';
        end if;
        field_combo.MSK_Control.clear_counts.next_q <= next_c;
        field_combo.MSK_Control.clear_counts.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.MSK_Control.clear_counts.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.MSK_Control.clear_counts.value <= '0';
            else
                if field_combo.MSK_Control.clear_counts.load_next then
                    field_storage.MSK_Control.clear_counts.value <= field_combo.MSK_Control.clear_counts.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.MSK_Control.clear_counts.value <= field_storage.MSK_Control.clear_counts.value;

    -- Field: msk_top_regs.MSK_Control.diff_encoder_loopback
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.MSK_Control.diff_encoder_loopback.value;
        load_next_c := '0';
        if decoded_reg_strb.MSK_Control and decoded_req_is_wr then -- SW write
            next_c := (field_storage.MSK_Control.diff_encoder_loopback.value and not decoded_wr_biten(4)) or (decoded_wr_data(4) and decoded_wr_biten(4));
            load_next_c := '1';
        end if;
        field_combo.MSK_Control.diff_encoder_loopback.next_q <= next_c;
        field_combo.MSK_Control.diff_encoder_loopback.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.MSK_Control.diff_encoder_loopback.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.MSK_Control.diff_encoder_loopback.value <= '0';
            else
                if field_combo.MSK_Control.diff_encoder_loopback.load_next then
                    field_storage.MSK_Control.diff_encoder_loopback.value <= field_combo.MSK_Control.diff_encoder_loopback.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.MSK_Control.diff_encoder_loopback.value <= field_storage.MSK_Control.diff_encoder_loopback.value;

    -- Field: msk_top_regs.Fb_FreqWord.config_data
    process(all)
        variable next_c: std_logic_vector(31 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.Fb_FreqWord.config_data.value;
        load_next_c := '0';
        if decoded_reg_strb.Fb_FreqWord and decoded_req_is_wr then -- SW write
            next_c := (field_storage.Fb_FreqWord.config_data.value and not decoded_wr_biten(31 downto 0)) or (decoded_wr_data(31 downto 0) and decoded_wr_biten(31 downto 0));
            load_next_c := '1';
        end if;
        field_combo.Fb_FreqWord.config_data.next_q <= next_c;
        field_combo.Fb_FreqWord.config_data.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.Fb_FreqWord.config_data.value <= 32x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.Fb_FreqWord.config_data.value <= 32x"0";
            else
                if field_combo.Fb_FreqWord.config_data.load_next then
                    field_storage.Fb_FreqWord.config_data.value <= field_combo.Fb_FreqWord.config_data.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.Fb_FreqWord.config_data.value <= field_storage.Fb_FreqWord.config_data.value;

    -- Field: msk_top_regs.TX_F1_FreqWord.config_data
    process(all)
        variable next_c: std_logic_vector(31 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.TX_F1_FreqWord.config_data.value;
        load_next_c := '0';
        if decoded_reg_strb.TX_F1_FreqWord and decoded_req_is_wr then -- SW write
            next_c := (field_storage.TX_F1_FreqWord.config_data.value and not decoded_wr_biten(31 downto 0)) or (decoded_wr_data(31 downto 0) and decoded_wr_biten(31 downto 0));
            load_next_c := '1';
        end if;
        field_combo.TX_F1_FreqWord.config_data.next_q <= next_c;
        field_combo.TX_F1_FreqWord.config_data.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.TX_F1_FreqWord.config_data.value <= 32x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.TX_F1_FreqWord.config_data.value <= 32x"0";
            else
                if field_combo.TX_F1_FreqWord.config_data.load_next then
                    field_storage.TX_F1_FreqWord.config_data.value <= field_combo.TX_F1_FreqWord.config_data.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.TX_F1_FreqWord.config_data.value <= field_storage.TX_F1_FreqWord.config_data.value;

    -- Field: msk_top_regs.TX_F2_FreqWord.config_data
    process(all)
        variable next_c: std_logic_vector(31 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.TX_F2_FreqWord.config_data.value;
        load_next_c := '0';
        if decoded_reg_strb.TX_F2_FreqWord and decoded_req_is_wr then -- SW write
            next_c := (field_storage.TX_F2_FreqWord.config_data.value and not decoded_wr_biten(31 downto 0)) or (decoded_wr_data(31 downto 0) and decoded_wr_biten(31 downto 0));
            load_next_c := '1';
        end if;
        field_combo.TX_F2_FreqWord.config_data.next_q <= next_c;
        field_combo.TX_F2_FreqWord.config_data.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.TX_F2_FreqWord.config_data.value <= 32x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.TX_F2_FreqWord.config_data.value <= 32x"0";
            else
                if field_combo.TX_F2_FreqWord.config_data.load_next then
                    field_storage.TX_F2_FreqWord.config_data.value <= field_combo.TX_F2_FreqWord.config_data.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.TX_F2_FreqWord.config_data.value <= field_storage.TX_F2_FreqWord.config_data.value;

    -- Field: msk_top_regs.RX_F1_FreqWord.config_data
    process(all)
        variable next_c: std_logic_vector(31 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.RX_F1_FreqWord.config_data.value;
        load_next_c := '0';
        if decoded_reg_strb.RX_F1_FreqWord and decoded_req_is_wr then -- SW write
            next_c := (field_storage.RX_F1_FreqWord.config_data.value and not decoded_wr_biten(31 downto 0)) or (decoded_wr_data(31 downto 0) and decoded_wr_biten(31 downto 0));
            load_next_c := '1';
        end if;
        field_combo.RX_F1_FreqWord.config_data.next_q <= next_c;
        field_combo.RX_F1_FreqWord.config_data.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.RX_F1_FreqWord.config_data.value <= 32x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.RX_F1_FreqWord.config_data.value <= 32x"0";
            else
                if field_combo.RX_F1_FreqWord.config_data.load_next then
                    field_storage.RX_F1_FreqWord.config_data.value <= field_combo.RX_F1_FreqWord.config_data.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.RX_F1_FreqWord.config_data.value <= field_storage.RX_F1_FreqWord.config_data.value;

    -- Field: msk_top_regs.RX_F2_FreqWord.config_data
    process(all)
        variable next_c: std_logic_vector(31 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.RX_F2_FreqWord.config_data.value;
        load_next_c := '0';
        if decoded_reg_strb.RX_F2_FreqWord and decoded_req_is_wr then -- SW write
            next_c := (field_storage.RX_F2_FreqWord.config_data.value and not decoded_wr_biten(31 downto 0)) or (decoded_wr_data(31 downto 0) and decoded_wr_biten(31 downto 0));
            load_next_c := '1';
        end if;
        field_combo.RX_F2_FreqWord.config_data.next_q <= next_c;
        field_combo.RX_F2_FreqWord.config_data.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.RX_F2_FreqWord.config_data.value <= 32x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.RX_F2_FreqWord.config_data.value <= 32x"0";
            else
                if field_combo.RX_F2_FreqWord.config_data.load_next then
                    field_storage.RX_F2_FreqWord.config_data.value <= field_combo.RX_F2_FreqWord.config_data.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.RX_F2_FreqWord.config_data.value <= field_storage.RX_F2_FreqWord.config_data.value;

    -- Field: msk_top_regs.LPF_Config_0.lpf_freeze
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.LPF_Config_0.lpf_freeze.value;
        load_next_c := '0';
        if decoded_reg_strb.LPF_Config_0 and decoded_req_is_wr then -- SW write
            next_c := (field_storage.LPF_Config_0.lpf_freeze.value and not decoded_wr_biten(0)) or (decoded_wr_data(0) and decoded_wr_biten(0));
            load_next_c := '1';
        end if;
        field_combo.LPF_Config_0.lpf_freeze.next_q <= next_c;
        field_combo.LPF_Config_0.lpf_freeze.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.LPF_Config_0.lpf_freeze.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.LPF_Config_0.lpf_freeze.value <= '0';
            else
                if field_combo.LPF_Config_0.lpf_freeze.load_next then
                    field_storage.LPF_Config_0.lpf_freeze.value <= field_combo.LPF_Config_0.lpf_freeze.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.LPF_Config_0.lpf_freeze.value <= field_storage.LPF_Config_0.lpf_freeze.value;

    -- Field: msk_top_regs.LPF_Config_0.lpf_zero
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.LPF_Config_0.lpf_zero.value;
        load_next_c := '0';
        if decoded_reg_strb.LPF_Config_0 and decoded_req_is_wr then -- SW write
            next_c := (field_storage.LPF_Config_0.lpf_zero.value and not decoded_wr_biten(1)) or (decoded_wr_data(1) and decoded_wr_biten(1));
            load_next_c := '1';
        end if;
        field_combo.LPF_Config_0.lpf_zero.next_q <= next_c;
        field_combo.LPF_Config_0.lpf_zero.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.LPF_Config_0.lpf_zero.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.LPF_Config_0.lpf_zero.value <= '0';
            else
                if field_combo.LPF_Config_0.lpf_zero.load_next then
                    field_storage.LPF_Config_0.lpf_zero.value <= field_combo.LPF_Config_0.lpf_zero.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.LPF_Config_0.lpf_zero.value <= field_storage.LPF_Config_0.lpf_zero.value;

    -- Field: msk_top_regs.LPF_Config_0.prbs_reserved
    process(all)
        variable next_c: std_logic_vector(5 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.LPF_Config_0.prbs_reserved.value;
        load_next_c := '0';
        if decoded_reg_strb.LPF_Config_0 and decoded_req_is_wr then -- SW write
            next_c := (field_storage.LPF_Config_0.prbs_reserved.value and not decoded_wr_biten(7 downto 2)) or (decoded_wr_data(7 downto 2) and decoded_wr_biten(7 downto 2));
            load_next_c := '1';
        end if;
        field_combo.LPF_Config_0.prbs_reserved.next_q <= next_c;
        field_combo.LPF_Config_0.prbs_reserved.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.LPF_Config_0.prbs_reserved.value <= 6x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.LPF_Config_0.prbs_reserved.value <= 6x"0";
            else
                if field_combo.LPF_Config_0.prbs_reserved.load_next then
                    field_storage.LPF_Config_0.prbs_reserved.value <= field_combo.LPF_Config_0.prbs_reserved.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.LPF_Config_0.prbs_reserved.value <= field_storage.LPF_Config_0.prbs_reserved.value;

    -- Field: msk_top_regs.LPF_Config_0.lpf_alpha
    process(all)
        variable next_c: std_logic_vector(23 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.LPF_Config_0.lpf_alpha.value;
        load_next_c := '0';
        if decoded_reg_strb.LPF_Config_0 and decoded_req_is_wr then -- SW write
            next_c := (field_storage.LPF_Config_0.lpf_alpha.value and not decoded_wr_biten(31 downto 8)) or (decoded_wr_data(31 downto 8) and decoded_wr_biten(31 downto 8));
            load_next_c := '1';
        end if;
        field_combo.LPF_Config_0.lpf_alpha.next_q <= next_c;
        field_combo.LPF_Config_0.lpf_alpha.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.LPF_Config_0.lpf_alpha.value <= 24x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.LPF_Config_0.lpf_alpha.value <= 24x"0";
            else
                if field_combo.LPF_Config_0.lpf_alpha.load_next then
                    field_storage.LPF_Config_0.lpf_alpha.value <= field_combo.LPF_Config_0.lpf_alpha.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.LPF_Config_0.lpf_alpha.value <= field_storage.LPF_Config_0.lpf_alpha.value;

    -- Field: msk_top_regs.LPF_Config_1.i_gain
    process(all)
        variable next_c: std_logic_vector(23 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.LPF_Config_1.i_gain.value;
        load_next_c := '0';
        if decoded_reg_strb.LPF_Config_1 and decoded_req_is_wr then -- SW write
            next_c := (field_storage.LPF_Config_1.i_gain.value and not decoded_wr_biten(23 downto 0)) or (decoded_wr_data(23 downto 0) and decoded_wr_biten(23 downto 0));
            load_next_c := '1';
        end if;
        field_combo.LPF_Config_1.i_gain.next_q <= next_c;
        field_combo.LPF_Config_1.i_gain.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.LPF_Config_1.i_gain.value <= 24x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.LPF_Config_1.i_gain.value <= 24x"0";
            else
                if field_combo.LPF_Config_1.i_gain.load_next then
                    field_storage.LPF_Config_1.i_gain.value <= field_combo.LPF_Config_1.i_gain.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.LPF_Config_1.i_gain.value <= field_storage.LPF_Config_1.i_gain.value;

    -- Field: msk_top_regs.LPF_Config_1.i_shift
    process(all)
        variable next_c: std_logic_vector(7 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.LPF_Config_1.i_shift.value;
        load_next_c := '0';
        if decoded_reg_strb.LPF_Config_1 and decoded_req_is_wr then -- SW write
            next_c := (field_storage.LPF_Config_1.i_shift.value and not decoded_wr_biten(31 downto 24)) or (decoded_wr_data(31 downto 24) and decoded_wr_biten(31 downto 24));
            load_next_c := '1';
        end if;
        field_combo.LPF_Config_1.i_shift.next_q <= next_c;
        field_combo.LPF_Config_1.i_shift.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.LPF_Config_1.i_shift.value <= 8x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.LPF_Config_1.i_shift.value <= 8x"0";
            else
                if field_combo.LPF_Config_1.i_shift.load_next then
                    field_storage.LPF_Config_1.i_shift.value <= field_combo.LPF_Config_1.i_shift.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.LPF_Config_1.i_shift.value <= field_storage.LPF_Config_1.i_shift.value;

    -- Field: msk_top_regs.Tx_Data_Width.data_width
    process(all)
        variable next_c: std_logic_vector(7 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.Tx_Data_Width.data_width.value;
        load_next_c := '0';
        if decoded_reg_strb.Tx_Data_Width and decoded_req_is_wr then -- SW write
            next_c := (field_storage.Tx_Data_Width.data_width.value and not decoded_wr_biten(7 downto 0)) or (decoded_wr_data(7 downto 0) and decoded_wr_biten(7 downto 0));
            load_next_c := '1';
        end if;
        field_combo.Tx_Data_Width.data_width.next_q <= next_c;
        field_combo.Tx_Data_Width.data_width.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.Tx_Data_Width.data_width.value <= 8x"8";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.Tx_Data_Width.data_width.value <= 8x"8";
            else
                if field_combo.Tx_Data_Width.data_width.load_next then
                    field_storage.Tx_Data_Width.data_width.value <= field_combo.Tx_Data_Width.data_width.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.Tx_Data_Width.data_width.value <= field_storage.Tx_Data_Width.data_width.value;

    -- Field: msk_top_regs.Rx_Data_Width.data_width
    process(all)
        variable next_c: std_logic_vector(7 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.Rx_Data_Width.data_width.value;
        load_next_c := '0';
        if decoded_reg_strb.Rx_Data_Width and decoded_req_is_wr then -- SW write
            next_c := (field_storage.Rx_Data_Width.data_width.value and not decoded_wr_biten(7 downto 0)) or (decoded_wr_data(7 downto 0) and decoded_wr_biten(7 downto 0));
            load_next_c := '1';
        end if;
        field_combo.Rx_Data_Width.data_width.next_q <= next_c;
        field_combo.Rx_Data_Width.data_width.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.Rx_Data_Width.data_width.value <= 8x"8";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.Rx_Data_Width.data_width.value <= 8x"8";
            else
                if field_combo.Rx_Data_Width.data_width.load_next then
                    field_storage.Rx_Data_Width.data_width.value <= field_combo.Rx_Data_Width.data_width.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.Rx_Data_Width.data_width.value <= field_storage.Rx_Data_Width.data_width.value;

    -- Field: msk_top_regs.PRBS_Control.prbs_sel
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.PRBS_Control.prbs_sel.value;
        load_next_c := '0';
        if decoded_reg_strb.PRBS_Control and decoded_req_is_wr then -- SW write
            next_c := (field_storage.PRBS_Control.prbs_sel.value and not decoded_wr_biten(0)) or (decoded_wr_data(0) and decoded_wr_biten(0));
            load_next_c := '1';
        end if;
        field_combo.PRBS_Control.prbs_sel.next_q <= next_c;
        field_combo.PRBS_Control.prbs_sel.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.PRBS_Control.prbs_sel.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.PRBS_Control.prbs_sel.value <= '0';
            else
                if field_combo.PRBS_Control.prbs_sel.load_next then
                    field_storage.PRBS_Control.prbs_sel.value <= field_combo.PRBS_Control.prbs_sel.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.PRBS_Control.prbs_sel.value <= field_storage.PRBS_Control.prbs_sel.value;

    -- Field: msk_top_regs.PRBS_Control.prbs_error_insert
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.PRBS_Control.prbs_error_insert.value;
        load_next_c := '0';
        if decoded_reg_strb.PRBS_Control and decoded_req_is_wr then -- SW write
            next_c := (field_storage.PRBS_Control.prbs_error_insert.value and not decoded_wr_biten(1)) or (decoded_wr_data(1) and decoded_wr_biten(1));
            load_next_c := '1';
        else -- singlepulse clears back to 0
            next_c := '0';
            load_next_c := '1';
        end if;
        field_combo.PRBS_Control.prbs_error_insert.next_q <= next_c;
        field_combo.PRBS_Control.prbs_error_insert.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.PRBS_Control.prbs_error_insert.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.PRBS_Control.prbs_error_insert.value <= '0';
            else
                if field_combo.PRBS_Control.prbs_error_insert.load_next then
                    field_storage.PRBS_Control.prbs_error_insert.value <= field_combo.PRBS_Control.prbs_error_insert.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.PRBS_Control.prbs_error_insert.value <= field_storage.PRBS_Control.prbs_error_insert.value;

    -- Field: msk_top_regs.PRBS_Control.prbs_clear
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.PRBS_Control.prbs_clear.value;
        load_next_c := '0';
        if decoded_reg_strb.PRBS_Control and decoded_req_is_wr then -- SW write
            next_c := (field_storage.PRBS_Control.prbs_clear.value and not decoded_wr_biten(2)) or (decoded_wr_data(2) and decoded_wr_biten(2));
            load_next_c := '1';
        else -- singlepulse clears back to 0
            next_c := '0';
            load_next_c := '1';
        end if;
        field_combo.PRBS_Control.prbs_clear.next_q <= next_c;
        field_combo.PRBS_Control.prbs_clear.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.PRBS_Control.prbs_clear.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.PRBS_Control.prbs_clear.value <= '0';
            else
                if field_combo.PRBS_Control.prbs_clear.load_next then
                    field_storage.PRBS_Control.prbs_clear.value <= field_combo.PRBS_Control.prbs_clear.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.PRBS_Control.prbs_clear.value <= field_storage.PRBS_Control.prbs_clear.value;

    -- Field: msk_top_regs.PRBS_Control.prbs_manual_sync
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.PRBS_Control.prbs_manual_sync.value;
        load_next_c := '0';
        if decoded_reg_strb.PRBS_Control and decoded_req_is_wr then -- SW write
            next_c := (field_storage.PRBS_Control.prbs_manual_sync.value and not decoded_wr_biten(3)) or (decoded_wr_data(3) and decoded_wr_biten(3));
            load_next_c := '1';
        else -- singlepulse clears back to 0
            next_c := '0';
            load_next_c := '1';
        end if;
        field_combo.PRBS_Control.prbs_manual_sync.next_q <= next_c;
        field_combo.PRBS_Control.prbs_manual_sync.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.PRBS_Control.prbs_manual_sync.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.PRBS_Control.prbs_manual_sync.value <= '0';
            else
                if field_combo.PRBS_Control.prbs_manual_sync.load_next then
                    field_storage.PRBS_Control.prbs_manual_sync.value <= field_combo.PRBS_Control.prbs_manual_sync.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.PRBS_Control.prbs_manual_sync.value <= field_storage.PRBS_Control.prbs_manual_sync.value;

    -- Field: msk_top_regs.PRBS_Control.prbs_reserved
    process(all)
        variable next_c: std_logic_vector(11 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.PRBS_Control.prbs_reserved.value;
        load_next_c := '0';
        if decoded_reg_strb.PRBS_Control and decoded_req_is_wr then -- SW write
            next_c := (field_storage.PRBS_Control.prbs_reserved.value and not decoded_wr_biten(15 downto 4)) or (decoded_wr_data(15 downto 4) and decoded_wr_biten(15 downto 4));
            load_next_c := '1';
        end if;
        field_combo.PRBS_Control.prbs_reserved.next_q <= next_c;
        field_combo.PRBS_Control.prbs_reserved.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.PRBS_Control.prbs_reserved.value <= 12x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.PRBS_Control.prbs_reserved.value <= 12x"0";
            else
                if field_combo.PRBS_Control.prbs_reserved.load_next then
                    field_storage.PRBS_Control.prbs_reserved.value <= field_combo.PRBS_Control.prbs_reserved.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.PRBS_Control.prbs_reserved.value <= field_storage.PRBS_Control.prbs_reserved.value;

    -- Field: msk_top_regs.PRBS_Control.prbs_sync_threshold
    process(all)
        variable next_c: std_logic_vector(15 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.PRBS_Control.prbs_sync_threshold.value;
        load_next_c := '0';
        if decoded_reg_strb.PRBS_Control and decoded_req_is_wr then -- SW write
            next_c := (field_storage.PRBS_Control.prbs_sync_threshold.value and not decoded_wr_biten(31 downto 16)) or (decoded_wr_data(31 downto 16) and decoded_wr_biten(31 downto 16));
            load_next_c := '1';
        end if;
        field_combo.PRBS_Control.prbs_sync_threshold.next_q <= next_c;
        field_combo.PRBS_Control.prbs_sync_threshold.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.PRBS_Control.prbs_sync_threshold.value <= 16x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.PRBS_Control.prbs_sync_threshold.value <= 16x"0";
            else
                if field_combo.PRBS_Control.prbs_sync_threshold.load_next then
                    field_storage.PRBS_Control.prbs_sync_threshold.value <= field_combo.PRBS_Control.prbs_sync_threshold.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.PRBS_Control.prbs_sync_threshold.value <= field_storage.PRBS_Control.prbs_sync_threshold.value;

    -- Field: msk_top_regs.PRBS_Initial_State.config_data
    process(all)
        variable next_c: std_logic_vector(31 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.PRBS_Initial_State.config_data.value;
        load_next_c := '0';
        if decoded_reg_strb.PRBS_Initial_State and decoded_req_is_wr then -- SW write
            next_c := (field_storage.PRBS_Initial_State.config_data.value and not decoded_wr_biten(31 downto 0)) or (decoded_wr_data(31 downto 0) and decoded_wr_biten(31 downto 0));
            load_next_c := '1';
        end if;
        field_combo.PRBS_Initial_State.config_data.next_q <= next_c;
        field_combo.PRBS_Initial_State.config_data.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.PRBS_Initial_State.config_data.value <= 32x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.PRBS_Initial_State.config_data.value <= 32x"0";
            else
                if field_combo.PRBS_Initial_State.config_data.load_next then
                    field_storage.PRBS_Initial_State.config_data.value <= field_combo.PRBS_Initial_State.config_data.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.PRBS_Initial_State.config_data.value <= field_storage.PRBS_Initial_State.config_data.value;

    -- Field: msk_top_regs.PRBS_Polynomial.config_data
    process(all)
        variable next_c: std_logic_vector(31 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.PRBS_Polynomial.config_data.value;
        load_next_c := '0';
        if decoded_reg_strb.PRBS_Polynomial and decoded_req_is_wr then -- SW write
            next_c := (field_storage.PRBS_Polynomial.config_data.value and not decoded_wr_biten(31 downto 0)) or (decoded_wr_data(31 downto 0) and decoded_wr_biten(31 downto 0));
            load_next_c := '1';
        end if;
        field_combo.PRBS_Polynomial.config_data.next_q <= next_c;
        field_combo.PRBS_Polynomial.config_data.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.PRBS_Polynomial.config_data.value <= 32x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.PRBS_Polynomial.config_data.value <= 32x"0";
            else
                if field_combo.PRBS_Polynomial.config_data.load_next then
                    field_storage.PRBS_Polynomial.config_data.value <= field_combo.PRBS_Polynomial.config_data.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.PRBS_Polynomial.config_data.value <= field_storage.PRBS_Polynomial.config_data.value;

    -- Field: msk_top_regs.PRBS_Error_Mask.config_data
    process(all)
        variable next_c: std_logic_vector(31 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.PRBS_Error_Mask.config_data.value;
        load_next_c := '0';
        if decoded_reg_strb.PRBS_Error_Mask and decoded_req_is_wr then -- SW write
            next_c := (field_storage.PRBS_Error_Mask.config_data.value and not decoded_wr_biten(31 downto 0)) or (decoded_wr_data(31 downto 0) and decoded_wr_biten(31 downto 0));
            load_next_c := '1';
        end if;
        field_combo.PRBS_Error_Mask.config_data.next_q <= next_c;
        field_combo.PRBS_Error_Mask.config_data.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.PRBS_Error_Mask.config_data.value <= 32x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.PRBS_Error_Mask.config_data.value <= 32x"0";
            else
                if field_combo.PRBS_Error_Mask.config_data.load_next then
                    field_storage.PRBS_Error_Mask.config_data.value <= field_combo.PRBS_Error_Mask.config_data.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.PRBS_Error_Mask.config_data.value <= field_storage.PRBS_Error_Mask.config_data.value;

    -- Field: msk_top_regs.Rx_Sample_Discard.rx_sample_discard
    process(all)
        variable next_c: std_logic_vector(7 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.Rx_Sample_Discard.rx_sample_discard.value;
        load_next_c := '0';
        if decoded_reg_strb.Rx_Sample_Discard and decoded_req_is_wr then -- SW write
            next_c := (field_storage.Rx_Sample_Discard.rx_sample_discard.value and not decoded_wr_biten(7 downto 0)) or (decoded_wr_data(7 downto 0) and decoded_wr_biten(7 downto 0));
            load_next_c := '1';
        end if;
        field_combo.Rx_Sample_Discard.rx_sample_discard.next_q <= next_c;
        field_combo.Rx_Sample_Discard.rx_sample_discard.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.Rx_Sample_Discard.rx_sample_discard.value <= 8x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.Rx_Sample_Discard.rx_sample_discard.value <= 8x"0";
            else
                if field_combo.Rx_Sample_Discard.rx_sample_discard.load_next then
                    field_storage.Rx_Sample_Discard.rx_sample_discard.value <= field_combo.Rx_Sample_Discard.rx_sample_discard.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.Rx_Sample_Discard.rx_sample_discard.value <= field_storage.Rx_Sample_Discard.rx_sample_discard.value;

    -- Field: msk_top_regs.Rx_Sample_Discard.rx_nco_discard
    process(all)
        variable next_c: std_logic_vector(7 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.Rx_Sample_Discard.rx_nco_discard.value;
        load_next_c := '0';
        if decoded_reg_strb.Rx_Sample_Discard and decoded_req_is_wr then -- SW write
            next_c := (field_storage.Rx_Sample_Discard.rx_nco_discard.value and not decoded_wr_biten(15 downto 8)) or (decoded_wr_data(15 downto 8) and decoded_wr_biten(15 downto 8));
            load_next_c := '1';
        end if;
        field_combo.Rx_Sample_Discard.rx_nco_discard.next_q <= next_c;
        field_combo.Rx_Sample_Discard.rx_nco_discard.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.Rx_Sample_Discard.rx_nco_discard.value <= 8x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.Rx_Sample_Discard.rx_nco_discard.value <= 8x"0";
            else
                if field_combo.Rx_Sample_Discard.rx_nco_discard.load_next then
                    field_storage.Rx_Sample_Discard.rx_nco_discard.value <= field_combo.Rx_Sample_Discard.rx_nco_discard.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.Rx_Sample_Discard.rx_nco_discard.value <= field_storage.Rx_Sample_Discard.rx_nco_discard.value;

    -- Field: msk_top_regs.LPF_Config_2.p_gain
    process(all)
        variable next_c: std_logic_vector(23 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.LPF_Config_2.p_gain.value;
        load_next_c := '0';
        if decoded_reg_strb.LPF_Config_2 and decoded_req_is_wr then -- SW write
            next_c := (field_storage.LPF_Config_2.p_gain.value and not decoded_wr_biten(23 downto 0)) or (decoded_wr_data(23 downto 0) and decoded_wr_biten(23 downto 0));
            load_next_c := '1';
        end if;
        field_combo.LPF_Config_2.p_gain.next_q <= next_c;
        field_combo.LPF_Config_2.p_gain.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.LPF_Config_2.p_gain.value <= 24x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.LPF_Config_2.p_gain.value <= 24x"0";
            else
                if field_combo.LPF_Config_2.p_gain.load_next then
                    field_storage.LPF_Config_2.p_gain.value <= field_combo.LPF_Config_2.p_gain.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.LPF_Config_2.p_gain.value <= field_storage.LPF_Config_2.p_gain.value;

    -- Field: msk_top_regs.LPF_Config_2.p_shift
    process(all)
        variable next_c: std_logic_vector(7 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.LPF_Config_2.p_shift.value;
        load_next_c := '0';
        if decoded_reg_strb.LPF_Config_2 and decoded_req_is_wr then -- SW write
            next_c := (field_storage.LPF_Config_2.p_shift.value and not decoded_wr_biten(31 downto 24)) or (decoded_wr_data(31 downto 24) and decoded_wr_biten(31 downto 24));
            load_next_c := '1';
        end if;
        field_combo.LPF_Config_2.p_shift.next_q <= next_c;
        field_combo.LPF_Config_2.p_shift.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.LPF_Config_2.p_shift.value <= 8x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.LPF_Config_2.p_shift.value <= 8x"0";
            else
                if field_combo.LPF_Config_2.p_shift.load_next then
                    field_storage.LPF_Config_2.p_shift.value <= field_combo.LPF_Config_2.p_shift.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.LPF_Config_2.p_shift.value <= field_storage.LPF_Config_2.p_shift.value;

    -- Field: msk_top_regs.Tx_Sync_Ctrl.tx_sync_ena
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.Tx_Sync_Ctrl.tx_sync_ena.value;
        load_next_c := '0';
        if decoded_reg_strb.Tx_Sync_Ctrl and decoded_req_is_wr then -- SW write
            next_c := (field_storage.Tx_Sync_Ctrl.tx_sync_ena.value and not decoded_wr_biten(0)) or (decoded_wr_data(0) and decoded_wr_biten(0));
            load_next_c := '1';
        end if;
        field_combo.Tx_Sync_Ctrl.tx_sync_ena.next_q <= next_c;
        field_combo.Tx_Sync_Ctrl.tx_sync_ena.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.Tx_Sync_Ctrl.tx_sync_ena.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.Tx_Sync_Ctrl.tx_sync_ena.value <= '0';
            else
                if field_combo.Tx_Sync_Ctrl.tx_sync_ena.load_next then
                    field_storage.Tx_Sync_Ctrl.tx_sync_ena.value <= field_combo.Tx_Sync_Ctrl.tx_sync_ena.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.Tx_Sync_Ctrl.tx_sync_ena.value <= field_storage.Tx_Sync_Ctrl.tx_sync_ena.value;

    -- Field: msk_top_regs.Tx_Sync_Ctrl.tx_sync_force
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.Tx_Sync_Ctrl.tx_sync_force.value;
        load_next_c := '0';
        if decoded_reg_strb.Tx_Sync_Ctrl and decoded_req_is_wr then -- SW write
            next_c := (field_storage.Tx_Sync_Ctrl.tx_sync_force.value and not decoded_wr_biten(1)) or (decoded_wr_data(1) and decoded_wr_biten(1));
            load_next_c := '1';
        end if;
        field_combo.Tx_Sync_Ctrl.tx_sync_force.next_q <= next_c;
        field_combo.Tx_Sync_Ctrl.tx_sync_force.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.Tx_Sync_Ctrl.tx_sync_force.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.Tx_Sync_Ctrl.tx_sync_force.value <= '0';
            else
                if field_combo.Tx_Sync_Ctrl.tx_sync_force.load_next then
                    field_storage.Tx_Sync_Ctrl.tx_sync_force.value <= field_combo.Tx_Sync_Ctrl.tx_sync_force.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.Tx_Sync_Ctrl.tx_sync_force.value <= field_storage.Tx_Sync_Ctrl.tx_sync_force.value;

    -- Field: msk_top_regs.Tx_Sync_Ctrl.tx_sync_f1
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.Tx_Sync_Ctrl.tx_sync_f1.value;
        load_next_c := '0';
        if decoded_reg_strb.Tx_Sync_Ctrl and decoded_req_is_wr then -- SW write
            next_c := (field_storage.Tx_Sync_Ctrl.tx_sync_f1.value and not decoded_wr_biten(2)) or (decoded_wr_data(2) and decoded_wr_biten(2));
            load_next_c := '1';
        end if;
        field_combo.Tx_Sync_Ctrl.tx_sync_f1.next_q <= next_c;
        field_combo.Tx_Sync_Ctrl.tx_sync_f1.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.Tx_Sync_Ctrl.tx_sync_f1.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.Tx_Sync_Ctrl.tx_sync_f1.value <= '0';
            else
                if field_combo.Tx_Sync_Ctrl.tx_sync_f1.load_next then
                    field_storage.Tx_Sync_Ctrl.tx_sync_f1.value <= field_combo.Tx_Sync_Ctrl.tx_sync_f1.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.Tx_Sync_Ctrl.tx_sync_f1.value <= field_storage.Tx_Sync_Ctrl.tx_sync_f1.value;

    -- Field: msk_top_regs.Tx_Sync_Ctrl.tx_sync_f2
    process(all)
        variable next_c: std_logic;
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.Tx_Sync_Ctrl.tx_sync_f2.value;
        load_next_c := '0';
        if decoded_reg_strb.Tx_Sync_Ctrl and decoded_req_is_wr then -- SW write
            next_c := (field_storage.Tx_Sync_Ctrl.tx_sync_f2.value and not decoded_wr_biten(3)) or (decoded_wr_data(3) and decoded_wr_biten(3));
            load_next_c := '1';
        end if;
        field_combo.Tx_Sync_Ctrl.tx_sync_f2.next_q <= next_c;
        field_combo.Tx_Sync_Ctrl.tx_sync_f2.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.Tx_Sync_Ctrl.tx_sync_f2.value <= '0';
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.Tx_Sync_Ctrl.tx_sync_f2.value <= '0';
            else
                if field_combo.Tx_Sync_Ctrl.tx_sync_f2.load_next then
                    field_storage.Tx_Sync_Ctrl.tx_sync_f2.value <= field_combo.Tx_Sync_Ctrl.tx_sync_f2.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.Tx_Sync_Ctrl.tx_sync_f2.value <= field_storage.Tx_Sync_Ctrl.tx_sync_f2.value;

    -- Field: msk_top_regs.Tx_Sync_Cnt.tx_sync_cnt
    process(all)
        variable next_c: std_logic_vector(23 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.Tx_Sync_Cnt.tx_sync_cnt.value;
        load_next_c := '0';
        if decoded_reg_strb.Tx_Sync_Cnt and decoded_req_is_wr then -- SW write
            next_c := (field_storage.Tx_Sync_Cnt.tx_sync_cnt.value and not decoded_wr_biten(23 downto 0)) or (decoded_wr_data(23 downto 0) and decoded_wr_biten(23 downto 0));
            load_next_c := '1';
        end if;
        field_combo.Tx_Sync_Cnt.tx_sync_cnt.next_q <= next_c;
        field_combo.Tx_Sync_Cnt.tx_sync_cnt.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.Tx_Sync_Cnt.tx_sync_cnt.value <= 24x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.Tx_Sync_Cnt.tx_sync_cnt.value <= 24x"0";
            else
                if field_combo.Tx_Sync_Cnt.tx_sync_cnt.load_next then
                    field_storage.Tx_Sync_Cnt.tx_sync_cnt.value <= field_combo.Tx_Sync_Cnt.tx_sync_cnt.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.Tx_Sync_Cnt.tx_sync_cnt.value <= field_storage.Tx_Sync_Cnt.tx_sync_cnt.value;

    -- Field: msk_top_regs.lowpass_ema_alpha1.alpha
    process(all)
        variable next_c: std_logic_vector(17 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.lowpass_ema_alpha1.alpha.value;
        load_next_c := '0';
        if decoded_reg_strb.lowpass_ema_alpha1 and decoded_req_is_wr then -- SW write
            next_c := (field_storage.lowpass_ema_alpha1.alpha.value and not decoded_wr_biten(17 downto 0)) or (decoded_wr_data(17 downto 0) and decoded_wr_biten(17 downto 0));
            load_next_c := '1';
        end if;
        field_combo.lowpass_ema_alpha1.alpha.next_q <= next_c;
        field_combo.lowpass_ema_alpha1.alpha.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.lowpass_ema_alpha1.alpha.value <= 18x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.lowpass_ema_alpha1.alpha.value <= 18x"0";
            else
                if field_combo.lowpass_ema_alpha1.alpha.load_next then
                    field_storage.lowpass_ema_alpha1.alpha.value <= field_combo.lowpass_ema_alpha1.alpha.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.lowpass_ema_alpha1.alpha.value <= field_storage.lowpass_ema_alpha1.alpha.value;

    -- Field: msk_top_regs.lowpass_ema_alpha2.alpha
    process(all)
        variable next_c: std_logic_vector(17 downto 0);
        variable load_next_c: std_logic;
    begin
        next_c := field_storage.lowpass_ema_alpha2.alpha.value;
        load_next_c := '0';
        if decoded_reg_strb.lowpass_ema_alpha2 and decoded_req_is_wr then -- SW write
            next_c := (field_storage.lowpass_ema_alpha2.alpha.value and not decoded_wr_biten(17 downto 0)) or (decoded_wr_data(17 downto 0) and decoded_wr_biten(17 downto 0));
            load_next_c := '1';
        end if;
        field_combo.lowpass_ema_alpha2.alpha.next_q <= next_c;
        field_combo.lowpass_ema_alpha2.alpha.load_next <= load_next_c;
    end process;
    process(clk) begin
        if false then -- async reset
            field_storage.lowpass_ema_alpha2.alpha.value <= 18x"0";
        elsif rising_edge(clk) then
            if rst then -- sync reset
                field_storage.lowpass_ema_alpha2.alpha.value <= 18x"0";
            else
                if field_combo.lowpass_ema_alpha2.alpha.load_next then
                    field_storage.lowpass_ema_alpha2.alpha.value <= field_combo.lowpass_ema_alpha2.alpha.next_q;
                end if;
            end if;
        end if;
    end process;
    hwif_out.lowpass_ema_alpha2.alpha.value <= field_storage.lowpass_ema_alpha2.alpha.value;

    ----------------------------------------------------------------------------
    -- Write response
    ----------------------------------------------------------------------------
    cpuif_wr_ack <= decoded_req and decoded_req_is_wr;
    -- Writes are always granted with no error response
    cpuif_wr_err <= '0';

    ----------------------------------------------------------------------------
    -- Readback
    ----------------------------------------------------------------------------

    -- Assign readback values to a flattened array
    readback_array(0)(31 downto 0) <= 32x"AAAA5555" when (decoded_reg_strb.Hash_ID_Low and not decoded_req_is_wr) else (others => '0');
    readback_array(1)(31 downto 0) <= 32x"5555AAAA" when (decoded_reg_strb.Hash_ID_High and not decoded_req_is_wr) else (others => '0');
    readback_array(2)(0 downto 0) <= to_std_logic_vector(field_storage.MSK_Init.txrxinit.value) when (decoded_reg_strb.MSK_Init and not decoded_req_is_wr) else (others => '0');
    readback_array(2)(1 downto 1) <= to_std_logic_vector(field_storage.MSK_Init.txinit.value) when (decoded_reg_strb.MSK_Init and not decoded_req_is_wr) else (others => '0');
    readback_array(2)(2 downto 2) <= to_std_logic_vector(field_storage.MSK_Init.rxinit.value) when (decoded_reg_strb.MSK_Init and not decoded_req_is_wr) else (others => '0');
    readback_array(2)(31 downto 3) <= (others => '0');
    readback_array(3)(0 downto 0) <= to_std_logic_vector(field_storage.MSK_Control.ptt.value) when (decoded_reg_strb.MSK_Control and not decoded_req_is_wr) else (others => '0');
    readback_array(3)(1 downto 1) <= to_std_logic_vector(field_storage.MSK_Control.loopback_ena.value) when (decoded_reg_strb.MSK_Control and not decoded_req_is_wr) else (others => '0');
    readback_array(3)(2 downto 2) <= to_std_logic_vector(field_storage.MSK_Control.rx_invert.value) when (decoded_reg_strb.MSK_Control and not decoded_req_is_wr) else (others => '0');
    readback_array(3)(3 downto 3) <= to_std_logic_vector(field_storage.MSK_Control.clear_counts.value) when (decoded_reg_strb.MSK_Control and not decoded_req_is_wr) else (others => '0');
    readback_array(3)(4 downto 4) <= to_std_logic_vector(field_storage.MSK_Control.diff_encoder_loopback.value) when (decoded_reg_strb.MSK_Control and not decoded_req_is_wr) else (others => '0');
    readback_array(3)(31 downto 5) <= (others => '0');
    readback_array(4)(0 downto 0) <= to_std_logic_vector(hwif_in.MSK_Status.demod_sync_lock.next_q) when (decoded_reg_strb.MSK_Status and not decoded_req_is_wr) else (others => '0');
    readback_array(4)(1 downto 1) <= to_std_logic_vector(hwif_in.MSK_Status.tx_enable.next_q) when (decoded_reg_strb.MSK_Status and not decoded_req_is_wr) else (others => '0');
    readback_array(4)(2 downto 2) <= to_std_logic_vector(hwif_in.MSK_Status.rx_enable.next_q) when (decoded_reg_strb.MSK_Status and not decoded_req_is_wr) else (others => '0');
    readback_array(4)(3 downto 3) <= to_std_logic_vector(hwif_in.MSK_Status.tx_axis_valid.next_q) when (decoded_reg_strb.MSK_Status and not decoded_req_is_wr) else (others => '0');
    readback_array(4)(31 downto 4) <= (others => '0');
    readback_array(5)(31 downto 0) <= hwif_in.Tx_Bit_Count.tx_bit_counter.next_q when (decoded_reg_strb.Tx_Bit_Count and not decoded_req_is_wr) else (others => '0');
    readback_array(6)(31 downto 0) <= hwif_in.Tx_Enable_Count.tx_ena_counter.next_q when (decoded_reg_strb.Tx_Enable_Count and not decoded_req_is_wr) else (others => '0');
    readback_array(7)(31 downto 0) <= field_storage.Fb_FreqWord.config_data.value when (decoded_reg_strb.Fb_FreqWord and not decoded_req_is_wr) else (others => '0');
    readback_array(8)(31 downto 0) <= field_storage.TX_F1_FreqWord.config_data.value when (decoded_reg_strb.TX_F1_FreqWord and not decoded_req_is_wr) else (others => '0');
    readback_array(9)(31 downto 0) <= field_storage.TX_F2_FreqWord.config_data.value when (decoded_reg_strb.TX_F2_FreqWord and not decoded_req_is_wr) else (others => '0');
    readback_array(10)(31 downto 0) <= field_storage.RX_F1_FreqWord.config_data.value when (decoded_reg_strb.RX_F1_FreqWord and not decoded_req_is_wr) else (others => '0');
    readback_array(11)(31 downto 0) <= field_storage.RX_F2_FreqWord.config_data.value when (decoded_reg_strb.RX_F2_FreqWord and not decoded_req_is_wr) else (others => '0');
    readback_array(12)(0 downto 0) <= to_std_logic_vector(field_storage.LPF_Config_0.lpf_freeze.value) when (decoded_reg_strb.LPF_Config_0 and not decoded_req_is_wr) else (others => '0');
    readback_array(12)(1 downto 1) <= to_std_logic_vector(field_storage.LPF_Config_0.lpf_zero.value) when (decoded_reg_strb.LPF_Config_0 and not decoded_req_is_wr) else (others => '0');
    readback_array(12)(7 downto 2) <= field_storage.LPF_Config_0.prbs_reserved.value when (decoded_reg_strb.LPF_Config_0 and not decoded_req_is_wr) else (others => '0');
    readback_array(12)(31 downto 8) <= field_storage.LPF_Config_0.lpf_alpha.value when (decoded_reg_strb.LPF_Config_0 and not decoded_req_is_wr) else (others => '0');
    readback_array(13)(23 downto 0) <= field_storage.LPF_Config_1.i_gain.value when (decoded_reg_strb.LPF_Config_1 and not decoded_req_is_wr) else (others => '0');
    readback_array(13)(31 downto 24) <= field_storage.LPF_Config_1.i_shift.value when (decoded_reg_strb.LPF_Config_1 and not decoded_req_is_wr) else (others => '0');
    readback_array(14)(7 downto 0) <= field_storage.Tx_Data_Width.data_width.value when (decoded_reg_strb.Tx_Data_Width and not decoded_req_is_wr) else (others => '0');
    readback_array(14)(31 downto 8) <= (others => '0');
    readback_array(15)(7 downto 0) <= field_storage.Rx_Data_Width.data_width.value when (decoded_reg_strb.Rx_Data_Width and not decoded_req_is_wr) else (others => '0');
    readback_array(15)(31 downto 8) <= (others => '0');
    readback_array(16)(0 downto 0) <= to_std_logic_vector(field_storage.PRBS_Control.prbs_sel.value) when (decoded_reg_strb.PRBS_Control and not decoded_req_is_wr) else (others => '0');
    readback_array(16)(3 downto 1) <= (others => '0');
    readback_array(16)(15 downto 4) <= field_storage.PRBS_Control.prbs_reserved.value when (decoded_reg_strb.PRBS_Control and not decoded_req_is_wr) else (others => '0');
    readback_array(16)(31 downto 16) <= field_storage.PRBS_Control.prbs_sync_threshold.value when (decoded_reg_strb.PRBS_Control and not decoded_req_is_wr) else (others => '0');
    readback_array(17)(31 downto 0) <= field_storage.PRBS_Initial_State.config_data.value when (decoded_reg_strb.PRBS_Initial_State and not decoded_req_is_wr) else (others => '0');
    readback_array(18)(31 downto 0) <= field_storage.PRBS_Polynomial.config_data.value when (decoded_reg_strb.PRBS_Polynomial and not decoded_req_is_wr) else (others => '0');
    readback_array(19)(31 downto 0) <= field_storage.PRBS_Error_Mask.config_data.value when (decoded_reg_strb.PRBS_Error_Mask and not decoded_req_is_wr) else (others => '0');
    readback_array(20)(31 downto 0) <= hwif_in.PRBS_Bit_Count.status_data.next_q when (decoded_reg_strb.PRBS_Bit_Count and not decoded_req_is_wr) else (others => '0');
    readback_array(21)(31 downto 0) <= hwif_in.PRBS_Error_Count.status_data.next_q when (decoded_reg_strb.PRBS_Error_Count and not decoded_req_is_wr) else (others => '0');
    readback_array(22)(31 downto 0) <= hwif_in.LPF_Accum_F1.status_data.next_q when (decoded_reg_strb.LPF_Accum_F1 and not decoded_req_is_wr) else (others => '0');
    readback_array(23)(31 downto 0) <= hwif_in.LPF_Accum_F2.status_data.next_q when (decoded_reg_strb.LPF_Accum_F2 and not decoded_req_is_wr) else (others => '0');
    readback_array(24)(31 downto 0) <= hwif_in.axis_xfer_count.xfer_count.next_q when (decoded_reg_strb.axis_xfer_count and not decoded_req_is_wr) else (others => '0');
    readback_array(25)(7 downto 0) <= field_storage.Rx_Sample_Discard.rx_sample_discard.value when (decoded_reg_strb.Rx_Sample_Discard and not decoded_req_is_wr) else (others => '0');
    readback_array(25)(15 downto 8) <= field_storage.Rx_Sample_Discard.rx_nco_discard.value when (decoded_reg_strb.Rx_Sample_Discard and not decoded_req_is_wr) else (others => '0');
    readback_array(25)(31 downto 16) <= (others => '0');
    readback_array(26)(23 downto 0) <= field_storage.LPF_Config_2.p_gain.value when (decoded_reg_strb.LPF_Config_2 and not decoded_req_is_wr) else (others => '0');
    readback_array(26)(31 downto 24) <= field_storage.LPF_Config_2.p_shift.value when (decoded_reg_strb.LPF_Config_2 and not decoded_req_is_wr) else (others => '0');
    readback_array(27)(31 downto 0) <= hwif_in.f1_nco_adjust.data.next_q when (decoded_reg_strb.f1_nco_adjust and not decoded_req_is_wr) else (others => '0');
    readback_array(28)(31 downto 0) <= hwif_in.f2_nco_adjust.data.next_q when (decoded_reg_strb.f2_nco_adjust and not decoded_req_is_wr) else (others => '0');
    readback_array(29)(31 downto 0) <= hwif_in.f1_error.data.next_q when (decoded_reg_strb.f1_error and not decoded_req_is_wr) else (others => '0');
    readback_array(30)(31 downto 0) <= hwif_in.f2_error.data.next_q when (decoded_reg_strb.f2_error and not decoded_req_is_wr) else (others => '0');
    readback_array(31)(0 downto 0) <= to_std_logic_vector(field_storage.Tx_Sync_Ctrl.tx_sync_ena.value) when (decoded_reg_strb.Tx_Sync_Ctrl and not decoded_req_is_wr) else (others => '0');
    readback_array(31)(1 downto 1) <= to_std_logic_vector(field_storage.Tx_Sync_Ctrl.tx_sync_force.value) when (decoded_reg_strb.Tx_Sync_Ctrl and not decoded_req_is_wr) else (others => '0');
    readback_array(31)(2 downto 2) <= to_std_logic_vector(field_storage.Tx_Sync_Ctrl.tx_sync_f1.value) when (decoded_reg_strb.Tx_Sync_Ctrl and not decoded_req_is_wr) else (others => '0');
    readback_array(31)(3 downto 3) <= to_std_logic_vector(field_storage.Tx_Sync_Ctrl.tx_sync_f2.value) when (decoded_reg_strb.Tx_Sync_Ctrl and not decoded_req_is_wr) else (others => '0');
    readback_array(31)(31 downto 4) <= (others => '0');
    readback_array(32)(23 downto 0) <= field_storage.Tx_Sync_Cnt.tx_sync_cnt.value when (decoded_reg_strb.Tx_Sync_Cnt and not decoded_req_is_wr) else (others => '0');
    readback_array(32)(31 downto 24) <= (others => '0');
    readback_array(33)(17 downto 0) <= field_storage.lowpass_ema_alpha1.alpha.value when (decoded_reg_strb.lowpass_ema_alpha1 and not decoded_req_is_wr) else (others => '0');
    readback_array(33)(31 downto 18) <= (others => '0');
    readback_array(34)(17 downto 0) <= field_storage.lowpass_ema_alpha2.alpha.value when (decoded_reg_strb.lowpass_ema_alpha2 and not decoded_req_is_wr) else (others => '0');
    readback_array(34)(31 downto 18) <= (others => '0');
    readback_array(35)(22 downto 0) <= hwif_in.rx_power.rx_power.next_q when (decoded_reg_strb.rx_power and not decoded_req_is_wr) else (others => '0');
    readback_array(35)(31 downto 23) <= (others => '0');

    -- Reduce the array
    process(all)
        variable readback_data_var : std_logic_vector(31 downto 0) := (others => '0');
    begin
        readback_done <= decoded_req and not decoded_req_is_wr;
        readback_err <= '0';
        readback_data_var := (others => '0');
        for i in readback_array'RANGE loop
            readback_data_var := readback_data_var or readback_array(i);
        end loop;
        readback_data <= readback_data_var;
    end process;

    cpuif_rd_ack <= readback_done;
    cpuif_rd_data <= readback_data;
    cpuif_rd_err <= readback_err;
end architecture rtl;
