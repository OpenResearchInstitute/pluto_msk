"""
peakrdl-python is a tool to generate Python Register Access Layer (RAL) from SystemRDL
Copyright (C) 2021 - 2023

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

This module is intended to distributed as part of automatically generated code by the
peakrdl-python tool. It provides a set of classes used by the autogenerated code to represent
registers and fields
"""
from enum import Enum
from typing import Union, cast, Optional, TypeVar
from collections.abc import Generator, Iterator
from abc import ABC, abstractmethod
from contextlib import contextmanager
from array import array as Array
import sys
from warnings import warn

from .base import AddressMap, RegFile
from .utility_functions import get_array_typecode
from .memory import  MemoryReadOnly, MemoryWriteOnly, MemoryReadWrite, Memory, \
    ReadableMemory, WritableMemory
from .memory import MemoryReadOnlyLegacy, MemoryWriteOnlyLegacy, MemoryReadWriteLegacy
from .memory import ReadableMemoryLegacy, WritableMemoryLegacy
from .callbacks import NormalCallbackSet, NormalCallbackSetLegacy
from .base_register import BaseReg, BaseRegArray, RegisterWriteVerifyError
from .base_field import FieldEnum, FieldSizeProps, FieldMiscProps, \
    _FieldReadOnlyFramework, _FieldWriteOnlyFramework, FieldType

# pylint: disable=duplicate-code
if sys.version_info >= (3, 11):
    from typing import Self
else:
    from typing_extensions import Self
# pylint: enable=duplicate-code

# pylint: disable=duplicate-code
if sys.version_info >= (3, 10):
    # type guarding was introduced in python 3.10
    from typing import TypeGuard
else:
    from typing_extensions import TypeGuard
# pylint: enable=duplicate-code

# pylint: disable=redefined-slots-in-subclass,too-many-lines


class Reg(BaseReg, ABC):
    """
        base class of non-async register wrappers

        Note:
            It is not expected that this class will be instantiated under normal
            circumstances however, it is useful for type checking
        """

    __slots__: list[str] = []

    # pylint: disable=too-many-arguments,duplicate-code
    def __init__(self, *,
                 address: int,
                 width: int,
                 accesswidth: int,
                 logger_handle: str,
                 inst_name: str,
                 parent: Union[AddressMap, RegFile, Memory, 'RegArray']):

        if not isinstance(parent, (AddressMap, RegFile,
                                   MemoryReadOnly, MemoryWriteOnly, MemoryReadWrite, RegArray,
                                   MemoryReadOnlyLegacy, MemoryWriteOnlyLegacy,
                                   MemoryReadWriteLegacy)):
            raise TypeError(f'bad parent type got: {type(parent)}')

        if not isinstance(parent._callbacks, (NormalCallbackSet, NormalCallbackSetLegacy)):
            raise TypeError(f'callback set type is wrong, got {type(parent._callbacks)}')

        super().__init__(address=address, width=width, accesswidth=accesswidth,
                         logger_handle=logger_handle, inst_name=inst_name, parent=parent)

    @property
    def _callbacks(self) -> Union[NormalCallbackSet, NormalCallbackSetLegacy]:
        # pylint: disable=protected-access
        if self.parent is None:
            raise RuntimeError('Parent must be set')

        if isinstance(self.parent._callbacks, (NormalCallbackSet, NormalCallbackSetLegacy)):
            return self.parent._callbacks

        raise TypeError(f'unhandled parent callback type: {type(self.parent._callbacks)}')

    @property
    @abstractmethod
    def fields(self) -> Iterator[Union['FieldReadOnly', 'FieldWriteOnly', 'FieldReadWrite']]:
        """
        generator that produces has all the fields within the register
        """


# pylint: disable-next=invalid-name
RegArrayElementType= TypeVar('RegArrayElementType', bound=BaseReg)


class RegArray(BaseRegArray, ABC):
    """
    base class of register array wrappers

    Note:
        It is not expected that this class will be instantiated under normal
        circumstances however, it is useful for type checking
    """
    # pylint: disable=too-many-arguments,duplicate-code

    __slots__: list[str] = ['__in_context_manager', '__register_cache',
                            '__register_address_array']

    def __init__(self, *,
                 logger_handle: str, inst_name: str,
                 parent: Union[AddressMap, RegFile, Memory],
                 width: int,
                 accesswidth: int,
                 address: int,
                 stride: int,
                 dimensions: tuple[int, ...],
                 elements: Optional[dict[tuple[int, ...], RegArrayElementType]] = None):

        self.__in_context_manager: bool = False
        self.__register_cache: Optional[Union[Array, list[int]]] = None
        self.__register_address_array: Optional[list[int]] = None

        if not isinstance(parent._callbacks, (NormalCallbackSet, NormalCallbackSetLegacy)):
            raise TypeError(f'callback set type is wrong, got {type(parent._callbacks)}')

        super().__init__(logger_handle=logger_handle, inst_name=inst_name,
                         parent=parent, address=address, width=width, accesswidth=accesswidth,
                         stride=stride, dimensions=dimensions, elements=elements)

    @property
    def __empty_array_cache(self) -> Array:
        return Array(get_array_typecode(self.width), self.__empty_list_cache)

    @property
    def __empty_list_cache(self) -> list[int]:
        return [0 for _ in range(self.__number_cache_entries)]

    def __block_read_legacy(self) -> Array:
        """
        Read all the contents of the array in the most optimal way, ideally with a block operation
        """
        if not isinstance(self._callbacks, NormalCallbackSetLegacy):
            raise RuntimeError('This function should only be used with legacy callbacks')

        read_block_callback = self._callbacks.read_block_callback
        read_callback = self._callbacks.read_callback

        if read_block_callback is not None:
            data_read = read_block_callback(addr=self.address, width=self.width,
                                            accesswidth=self.accesswidth,
                                            length=self.__number_cache_entries)

            if not isinstance(data_read, Array):
                raise TypeError('The read block callback is expected to return an array')

            return data_read

        if read_callback is not None:
            # there is not read_block_callback defined so we must used individual read
            data_array = self.__empty_array_cache

            if self.__register_address_array is None:
                raise RuntimeError('This address array has not be initialised')

            for entry, address in enumerate(self.__register_address_array):
                data_entry = read_callback(addr=address,
                                           width=self.width,
                                           accesswidth=self.accesswidth)

                data_array[entry] = data_entry

            return data_array

        raise RuntimeError('There is no usable callback')

    def __block_write_legacy(self, data: Array, verify: bool) -> None:
        """
        Write all the contents of the array in the most optimal way, ideally with a block operation
        """
        if not isinstance(self._callbacks, NormalCallbackSetLegacy):
            raise RuntimeError('This function should only be used with legacy callbacks')

        write_block_callback = self._callbacks.write_block_callback
        write_callback = self._callbacks.write_callback

        if write_block_callback is not None:
            write_block_callback(addr=self.address,
                                 width=self.width,
                                 accesswidth=self.width,
                                 data=data)

        elif write_callback is not None:
            # there is not write_block_callback defined so we must used individual write

            if self.__register_address_array is None:
                raise RuntimeError('This address array has not be initialised')

            for entry_index, entry_data in enumerate(data):
                entry_address = self.__register_address_array[entry_index]
                write_callback(addr=entry_address,
                               width=self.width,
                               accesswidth=self.accesswidth,
                               data=entry_data)

        else:
            raise RuntimeError('No suitable callback')

        if verify:
            read_back_verify_data = self.__block_read_legacy()
            if read_back_verify_data != data:
                raise RegisterWriteVerifyError('Read back block miss-match')

    def __block_read(self) -> list[int]:
        """
        Read all the contents of the array in the most optimal way, ideally with a block operation
        """
        if not isinstance(self._callbacks, NormalCallbackSet):
            raise RuntimeError('This function should only be used with non-legacy callbacks')

        read_block_callback = self._callbacks.read_block_callback
        read_callback = self._callbacks.read_callback

        if read_block_callback is not None:
            data_read = \
                read_block_callback(addr=self.address,
                                    width=self.width,
                                    accesswidth=self.accesswidth,
                                    length=self.__number_cache_entries)

            if not isinstance(data_read, list):
                if isinstance(data_read, Array):
                    raise TypeError('The read block callback is expected to return an list, this '
                                    'is likely to happen if you are using legacy callbacks without '
                                    'NormalCallbackSetLegacy')
                raise TypeError('The read block callback is expected to return an list')
            return data_read

        if read_callback is not None:
            # there is not read_block_callback defined so we must used individual read
            data_list = self.__empty_list_cache

            if self.__register_address_array is None:
                raise RuntimeError('This address array has not be initialised')

            for entry, address in enumerate(self.__register_address_array):
                data_entry = read_callback(addr=address,
                                           width=self.width,
                                           accesswidth=self.accesswidth)

                data_list[entry] = data_entry

            return data_list

        raise RuntimeError('There is no usable callback')

    def __block_write(self, data: list[int], verify: bool) -> None:
        """
        Write all the contents of the array in the most optimal way, ideally with a block operation
        """
        if not isinstance(self._callbacks, NormalCallbackSet):
            raise RuntimeError('This function should only be used with non-legacy callbacks')

        write_block_callback = self._callbacks.write_block_callback
        write_callback = self._callbacks.write_callback

        if write_block_callback is not None:
            write_block_callback(addr=self.address,
                                 width=self.width,
                                 accesswidth=self.width,
                                 data=data)

        elif write_callback is not None:
            # there is not write_block_callback defined so we must used individual write

            if self.__register_address_array is None:
                raise RuntimeError('This address array has not be initialised')

            for entry_index, entry_data in enumerate(data):
                entry_address = self.__register_address_array[entry_index]
                write_callback(addr=entry_address,
                               width=self.width,
                               accesswidth=self.accesswidth,
                               data=entry_data)

        else:
            raise RuntimeError('No suitable callback')

        if verify:
            read_back_verify_data = self.__block_read()
            if read_back_verify_data != data:
                raise RegisterWriteVerifyError('Read back block miss-match')

    def __cache_entry(self, addr: int, width: int, accesswidth: int) -> int:
        """
        Validate the data provided and determine the cache entry

        Args:
            addr: Address to write to
            width: Width of the register in bits
            accesswidth: Minimum access width of the register in bits

        Returns:
            cache entry

        """
        if not isinstance(width, int):
            raise TypeError(f'Width should be an int byt got {type(width)}')
        if width != self.width:
            raise ValueError('Requested Read width does not match the expected value')
        if not isinstance(accesswidth, int):
            raise TypeError(f'accesswidth should be an int byt got {type(accesswidth)}')
        if accesswidth != self.accesswidth:
            raise ValueError('Requested Read accesswidth does not match the expected value')
        if not isinstance(addr, int):
            raise TypeError(f'addr should be an int byt got {type(addr)}')
        if not self.address <= addr < (self.address + self.size):
            raise ValueError(f'Requested address 0x{addr:X} is out of range 0x{self.address:X} to '
                             f'0x{self.address + self.size - (self.width >> 3):X}')
        cache_entry = (addr - self.address) // (self.width >> 3)
        if self.__register_address_array is None:
            raise RuntimeError('The address table should always be populated here')
        if self.__register_address_array[cache_entry] != addr:
            raise RuntimeError(f'The calculated cache entry for address 0x{addr:X}')
        return cache_entry

    def __cache_read(self, addr: int, width: int, accesswidth: int) -> int:
        """
        Used to replace the normal callbacks with those that access the cache

        Args:
            addr: Address to write to
            width: Width of the register in bits
            accesswidth: Minimum access width of the register in bits

        Returns:
            value inputted by the used
        """
        if self.__register_cache is None:
            raise RuntimeError('The cache array should be initialised')
        return self.__register_cache[self.__cache_entry(addr=addr,
                                                        width=width,
                                                        accesswidth=accesswidth)]

    def __cache_write(self, addr: int, width: int, accesswidth: int, data: int) -> None:
        """
        Used to replace the normal callbacks with those that access the cache

        Args:
            addr: Address to write to
            width: Width of the register in bits
            accesswidth: Minimum access width of the register in bits
            data: value to be written to the register

        Returns:
            None
        """
        if not isinstance(data, int):
            raise TypeError(f'Data should be an int byt got {type(data)}')
        if self.__register_cache is None:
            raise RuntimeError('The cache array should be initialised')
        self.__register_cache[self.__cache_entry(addr=addr,
                                                 width=width,
                                                 accesswidth=accesswidth)] = data

    @property
    def __cache_callbacks(self) -> NormalCallbackSet:
        return NormalCallbackSet(read_callback=self.__cache_read,
                                 write_callback=self.__cache_write)

    @property
    def __number_cache_entries(self) -> int:
        return self.size // (self.width >> 3)

    def __initialise_cache(self, skip_initial_read: bool) -> Union[Array, list[int]]:
        if isinstance(self._callbacks, NormalCallbackSet):
            if skip_initial_read:
                return self.__empty_list_cache
            return self.__block_read()

        if isinstance(self._callbacks, NormalCallbackSetLegacy):
            if skip_initial_read:
                return self.__empty_array_cache
            return self.__block_read_legacy()

        raise TypeError('Unhandled callback type')

    @contextmanager
    def _cached_access(self, verify: bool = False, skip_write: bool = False,
                       skip_initial_read: bool = False) -> \
            Generator[Self]:
        """
        Context manager to allow multiple field reads/write to be done with a single set of
        field operations

        Args:
            verify (bool): very the write with a read afterwards
            skip_write (bool): skip the write back at the end
        """
        self.__register_address_array = \
            [self.address + (i * (self.width >> 3)) for i in range(self.__number_cache_entries)]
        self.__register_cache = self.__initialise_cache(skip_initial_read=skip_initial_read)
        self.__in_context_manager = True
        # this try/finally is needed to make sure that in the event of an exception
        # the state flags are not left incorrectly set
        try:
            yield self
        finally:
            self.__in_context_manager = False
        if not skip_write:
            if isinstance(self._callbacks, NormalCallbackSet):
                if not isinstance(self.__register_cache, list):
                    raise TypeError('Register cache should be a list in non-legacy mode')
                self.__block_write(self.__register_cache, verify)
            if isinstance(self._callbacks, NormalCallbackSetLegacy):
                if not isinstance(self.__register_cache, Array):
                    raise TypeError('Register cache should be a Array in legacy mode')
                self.__block_write_legacy(self.__register_cache, verify)

        # clear the register states at the end of the context manager
        self.__register_address_array = None
        self.__register_cache = None

    @property
    def _callbacks(self) -> NormalCallbackSet:

        if self.__in_context_manager:
            return self.__cache_callbacks

        if self.parent is None:
            raise RuntimeError('Parent must be set')
        # This cast is OK because the type was checked in the __init__
        # pylint: disable-next=protected-access
        return cast(NormalCallbackSet, self.parent._callbacks)


class RegReadOnly(Reg, ABC):
    """
    class for a read only register

    Args:
        address: address of the register
        width: width of the register in bits
        accesswidth: minimum access width of the register in bits
        logger_handle: name to be used logging messages associate with this
            object

    """

    __slots__: list[str] = ['__in_context_manager', '__register_state']

    # pylint: disable=too-many-arguments, duplicate-code
    def __init__(self, *,
                 address: int,
                 width: int,
                 accesswidth: int,
                 logger_handle: str,
                 inst_name: str,
                 parent: Union[AddressMap, RegFile, ReadableMemory, ReadableMemoryLegacy ]):

        super().__init__(address=address,
                         logger_handle=logger_handle,
                         inst_name=inst_name,
                         parent=parent, width=width, accesswidth=accesswidth)

        self.__in_context_manager: bool = False
        self.__register_state: int = 0

    # pylint: enable=too-many-arguments, duplicate-code

    @contextmanager
    def single_read(self) -> Generator[Self]:
        """
        Context manager to allow multiple field accesses to be performed with a single
        read of the register
        """
        self.__register_state = self.read()
        self.__in_context_manager = True
        # this try/finally is needed to make sure that in the event of an exception
        # the state flags are not left incorrectly set
        try:
            yield self
        finally:
            self.__in_context_manager = False

    def read(self) -> int:
        """
        Read value from the register
        """
        if self.__in_context_manager:
            return self.__register_state

        read_block_callback = self._callbacks.read_block_callback
        read_callback = self._callbacks.read_callback

        if read_callback is not None:
            return read_callback(addr=self.address,
                                 width=self.width,
                                 accesswidth=self.accesswidth)

        if read_block_callback is not None:
            return read_block_callback(addr=self.address,
                                       width=self.width,
                                       accesswidth=self.accesswidth,
                                       length=1)[0]

        raise RuntimeError('This function does not have a useable callback')

    @property
    def readable_fields(self) -> Iterator[Union['FieldReadOnly', 'FieldReadWrite']]:
        """
        generator that produces has all the readable fields within the register
        """
        def is_readable(field: Union['FieldReadOnly', 'FieldWriteOnly', 'FieldReadWrite']) -> \
                TypeGuard[Union['FieldReadOnly', 'FieldReadWrite']]:
            return isinstance(field, (FieldReadOnly, FieldReadWrite))

        return filter(is_readable, self.fields)

    def read_fields(self) -> dict['str', Union[bool, Enum, int]]:
        """
        read the register and return a dictionary of the field values
        """
        return_dict: dict['str', Union[bool, Enum, int]] = {}
        with self.single_read() as reg:
            for field in reg.readable_fields:
                return_dict[field.inst_name] = field.read()

        return return_dict

    @property
    def _is_readable(self) -> bool:
        # pylint: disable=duplicate-code
        return True

    @property
    def _is_writeable(self) -> bool:
        # pylint: disable=duplicate-code
        return False


class RegWriteOnly(Reg, ABC):
    """
    class for a write only register
    """

    __slots__: list[str] = []

    # pylint: disable=too-many-arguments, duplicate-code, useless-parent-delegation
    def __init__(self, *,
                 address: int,
                 width: int,
                 accesswidth: int,
                 logger_handle: str,
                 inst_name: str,
                 parent: Union[AddressMap, RegFile, WritableMemory, WritableMemoryLegacy]):

        super().__init__(address=address,
                         logger_handle=logger_handle,
                         inst_name=inst_name,
                         parent=parent, width=width, accesswidth=accesswidth)
    # pylint: enable=too-many-arguments, duplicate-code

    def write(self, data: int) -> None:
        """Writes a value to the register

        Args:
            data: data to be written

        Raises:
            ValueError: if the value provided is outside the range of the
                permissible values for the register
            TypeError: if the type of data is wrong
        """
        # this method check the types and range checks the data
        self._validate_data(data=data)

        self._logger.info('Writing data:%X to %X', data, self.address)

        if self._callbacks.write_callback is not None:
            self._callbacks.write_callback(addr=self.address,
                                           width=self.width,
                                           accesswidth=self.accesswidth,
                                           data=data)  #

        elif self._callbacks.write_block_callback is not None:
            if isinstance(self._callbacks, NormalCallbackSetLegacy):
                data_as_array = Array(get_array_typecode(self.width), [data])
                self._callbacks.write_block_callback(addr=self.address,
                                                     width=self.width,
                                                     accesswidth=self.accesswidth,
                                                     data=data_as_array)

            if isinstance(self._callbacks, NormalCallbackSet):
                self._callbacks.write_block_callback(addr=self.address,
                                                     width=self.width,
                                                     accesswidth=self.accesswidth,
                                                     data=[data])

        else:
            raise RuntimeError('This function does not have a useable callback')

    @property
    def writable_fields(self) -> Iterator[Union['FieldWriteOnly', 'FieldReadWrite']]:
        """
        generator that produces has all the readable fields within the register
        """
        def is_writable(field: Union['FieldReadOnly', 'FieldWriteOnly', 'FieldReadWrite']) -> \
                TypeGuard[Union['FieldWriteOnly', 'FieldReadWrite']]:
            return isinstance(field, (FieldWriteOnly, FieldReadWrite))

        return filter(is_writable, self.fields)

    @abstractmethod
    def write_fields(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Do a write to the register, updating any field included in
        the arguments
        """

    @property
    def _is_readable(self) -> bool:
        # pylint: disable=duplicate-code
        return False

    @property
    def _is_writeable(self) -> bool:
        # pylint: disable=duplicate-code
        return True


class RegReadWrite(RegReadOnly, RegWriteOnly, ABC):
    """
    class for a read and write only register

    """
    __slots__: list[str] = ['__in_read_write_context_manager', '__in_read_context_manager',
                            '__register_state']

    # pylint: disable=too-many-arguments, duplicate-code
    def __init__(self, *,
                 address: int,
                 width: int,
                 accesswidth: int,
                 logger_handle: str,
                 inst_name: str,
                 parent: Union[AddressMap, RegFile, MemoryReadWrite, MemoryReadWriteLegacy]):

        super().__init__(address=address,
                         logger_handle=logger_handle,
                         inst_name=inst_name,
                         parent=parent, width=width, accesswidth=accesswidth)

        self.__in_read_write_context_manager: bool = False
        self.__in_read_context_manager: bool = False
        self.__register_state: Optional[int] = None

    # pylint: enable=too-many-arguments, duplicate-code

    @contextmanager
    def single_read_modify_write(self, verify: bool = False, skip_write: bool = False) -> \
            Generator[Self]:
        """
        Context manager to allow multiple field reads/write to be done with a single set of
        field operations

        Args:
            verify (bool): very the write with a read afterwards
            skip_write (bool): skip the write back at the end

        """
        if self.__in_read_context_manager:
            raise RuntimeError('using the `single_read_modify_write` context manager within the '
                               'single_read` is not permitted')

        if skip_write is True:
            warn('The `skip_write` argument will be removed in the future, use `single_read`'
                 ' instead',
                 DeprecationWarning, stacklevel=2)

        self.__register_state = self.read()
        self.__in_read_write_context_manager = True
        try:
            yield self
        finally:
            # need to make sure the state flag is cleared even if an exception occurs within
            # the context
            self.__in_read_write_context_manager = False

        if not skip_write:
            self.write(self.__register_state, verify)

        # clear the register states at the end of the context manager
        self.__register_state = None

    @contextmanager
    def single_read(self) -> \
            Generator[Self]:
        """
        Context manager to allow multiple field reads with a single register read
        """
        if self.__in_read_write_context_manager:
            raise RuntimeError('using the `single_read` context manager within the '
                               'single_read_modify_write` is not permitted')
        self.__in_read_context_manager = True
        try:
            with super().single_read() as reg:
                yield reg
        finally:
            self.__in_read_context_manager = False

    def write(self, data: int, verify: bool = False) -> None:  # pylint: disable=arguments-differ
        """
        Writes a value to the register

        Args:
            data: data to be written
            verify: set to True to read back the register to verify the read has occurred correctly

        Raises:
            ValueError: if the value provided is outside the range of the
                        permissible values for the register
            TypeError: if the type of data is wrong
            RegisterWriteVerifyError: the read back data after the write does not match the
                                      expected value
        """
        if self.__in_read_context_manager:
            raise RuntimeError('writes within the single read context manager are not permitted')

        if self.__in_read_write_context_manager:
            if self.__register_state is None:
                raise RuntimeError('The internal register state should never be None in the '
                                   'context manager')
            self.__register_state = data
        else:
            super().write(data)
            if verify:
                read_back = self.read()
                if read_back != data:
                    raise RegisterWriteVerifyError(f'Readback {read_back:X} '
                                                   f'after writing {data:X}')

    def read(self) -> int:
        """
        Read value from the register
        """
        if self.__in_read_write_context_manager:
            if self.__register_state is None:
                raise RuntimeError('The internal register state should never be None in the '
                                   'context manager')
            return self.__register_state

        # the single read context manager is handled in the base class so does need any
        # handling here

        return super().read()

    def write_fields(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Do a read-modify-write to the register, updating any field included in
        the arguments
        """
        if len(kwargs) == 0:
            raise ValueError('no command args')

        with self.single_read_modify_write() as reg:
            for field_name, field_value in kwargs.items():
                if field_name not in reg.systemrdl_python_child_name_map.values():
                    raise ValueError(f'{field_name} is not a member of the register')

                field = getattr(reg, field_name)
                field.write(field_value)

    def read_fields(self) -> dict['str', Union[bool, Enum, int]]:
        """
        read the register and return a dictionary of the field values
        """
        return_dict: dict['str', Union[bool, Enum, int]] = {}
        with self.single_read() as reg:
            for field in reg.readable_fields:
                return_dict[field.inst_name] = field.read()

        return return_dict

    @property
    def _is_readable(self) -> bool:
        # pylint: disable=duplicate-code
        return True

    @property
    def _is_writeable(self) -> bool:
        # pylint: disable=duplicate-code
        return True


ReadableRegister = Union[RegReadOnly, RegReadWrite]
WritableRegister = Union[RegWriteOnly, RegReadWrite]


class RegReadOnlyArray(RegArray, ABC):
    """
    base class for a array of read only registers
    """
    __slots__: list[str] = []

    # pylint: disable=too-many-arguments,duplicate-code
    def __init__(self, *,
                 logger_handle: str, inst_name: str,
                 parent: Union[RegFile, AddressMap, ReadableMemory, ReadableMemoryLegacy],
                 address: int,
                 width: int,
                 accesswidth: int,
                 stride: int,
                 dimensions: tuple[int, ...],
                 elements: Optional[dict[tuple[int, ...], RegReadOnly]] = None):

        if not isinstance(parent, (RegFile, AddressMap, MemoryReadOnly, MemoryReadWrite,
                                   MemoryReadOnlyLegacy, MemoryReadWriteLegacy)):
            raise TypeError('parent should be either RegFile, AddressMap, '
                            'MemoryReadOnly, MemoryReadWrite '
                            f'got {type(parent)}')

        if not isinstance(parent._callbacks, (NormalCallbackSet, NormalCallbackSetLegacy)):
            raise TypeError(f'callback set type is wrong, got {type(parent._callbacks)}')

        super().__init__(logger_handle=logger_handle, inst_name=inst_name,
                         parent=parent, address=address, width=width, accesswidth=accesswidth,
                         stride=stride, dimensions=dimensions, elements=elements)
    # pylint: enable=too-many-arguments,duplicate-code

    @contextmanager
    def single_read(self) -> \
            Generator[Self]:
        """
        Context manager to allow multiple field reads/write to be done with a single set of
        field operations
        """
        with self._cached_access(verify=False, skip_write=True,
                                 skip_initial_read=False) as reg_array:
            yield reg_array

    @property
    def _is_readable(self) -> bool:
        # pylint: disable=duplicate-code
        return True

    @property
    def _is_writeable(self) -> bool:
        # pylint: disable=duplicate-code
        return False


class RegWriteOnlyArray(RegArray, ABC):
    """
    base class for a array of write only registers
    """
    __slots__: list[str] = []

    # pylint: disable=too-many-arguments,duplicate-code
    def __init__(self, *,
                 logger_handle: str, inst_name: str,
                 parent: Union[RegFile, AddressMap, WritableMemory, WritableMemoryLegacy],
                 address: int,
                 width: int,
                 accesswidth: int,
                 stride: int,
                 dimensions: tuple[int, ...],
                 elements: Optional[dict[tuple[int, ...], RegWriteOnly]] = None):

        if not isinstance(parent, (RegFile, AddressMap, MemoryWriteOnly, MemoryReadWrite,
                                   MemoryWriteOnlyLegacy, MemoryReadWriteLegacy)):
            raise TypeError('parent should be either RegFile, AddressMap, MemoryWriteOnly, '
                            'MemoryReadWrite '
                            f'got {type(parent)}')

        if not isinstance(parent._callbacks, (NormalCallbackSet, NormalCallbackSetLegacy)):
            raise TypeError(f'callback set type is wrong, got {type(parent._callbacks)}')

        super().__init__(logger_handle=logger_handle, inst_name=inst_name,
                         parent=parent, address=address, width=width, accesswidth=accesswidth,
                         stride=stride, dimensions=dimensions, elements=elements)
    # pylint: enable=too-many-arguments,duplicate-code

    @contextmanager
    def single_write(self) -> \
            Generator[Self]:
        """
        Context manager to allow multiple field reads/write to be done with a single set of
        field operations
        """
        with self._cached_access(verify=False, skip_write=False,
                                 skip_initial_read=True) as reg_array:
            yield reg_array

    @property
    def _is_readable(self) -> bool:
        # pylint: disable=duplicate-code
        return False

    @property
    def _is_writeable(self) -> bool:
        # pylint: disable=duplicate-code
        return True


class RegReadWriteArray(RegArray, ABC):
    """
    base class for a array of read and write registers
    """
    __slots__: list[str] = []

    # pylint: disable=too-many-arguments,duplicate-code
    def __init__(self, *,
                 logger_handle: str, inst_name: str,
                 parent: Union[RegFile, AddressMap, MemoryReadWrite, MemoryReadWriteLegacy],
                 address: int,
                 width: int,
                 accesswidth: int,
                 stride: int,
                 dimensions: tuple[int, ...],
                 elements: Optional[dict[tuple[int, ...], RegReadWrite]] = None):

        if not isinstance(parent, (RegFile, AddressMap, MemoryReadWrite, MemoryReadWriteLegacy)):
            raise TypeError('parent should be either RegFile, AddressMap, MemoryReadWrite '
                            f'got {type(parent)}')

        if not isinstance(parent._callbacks, (NormalCallbackSet, NormalCallbackSetLegacy)):
            raise TypeError(f'callback set type is wrong, got {type(parent._callbacks)}')

        super().__init__(logger_handle=logger_handle, inst_name=inst_name,
                         parent=parent, address=address, width=width, accesswidth=accesswidth,
                         stride=stride, dimensions=dimensions, elements=elements)

    # pylint: enable=too-many-arguments,duplicate-code

    @contextmanager
    def single_read_modify_write(self, verify: bool = False, skip_write: bool = False) -> \
            Generator[Self]:
        """
        Context manager to allow multiple field reads/write to be done with a single set of
        field operations

        Args:
            verify (bool): very the write with a read afterwards
            skip_write (bool): skip the write back at the end
        """
        with self._cached_access(verify=verify, skip_write=skip_write,
                                 skip_initial_read=False) as reg_array:
            yield reg_array

    @property
    def _is_readable(self) -> bool:
        # pylint: disable=duplicate-code
        return True

    @property
    def _is_writeable(self) -> bool:
        # pylint: disable=duplicate-code
        return True


ReadableRegisterArray = Union[RegReadOnlyArray, RegReadWriteArray]
WriteableRegisterArray = Union[RegWriteOnlyArray, RegReadWriteArray]


class FieldReadOnly(_FieldReadOnlyFramework[FieldType], ABC):
    """
    class for a read only register field

    Args:
        parent_register: register within which the field resides
        size_props: object defining the msb, lsb, high bit, low bit and width
        logger_handle: name to be used logging messages associate with this
            object

    """
    __slots__: list[str] = []

    # pylint: disable-next=too-many-arguments
    def __init__(self, *,
                 parent_register: ReadableRegister,
                 size_props: FieldSizeProps,
                 misc_props: FieldMiscProps,
                 logger_handle: str,
                 inst_name: str,
                 field_type:type[FieldType]):

        if not isinstance(parent_register, (RegReadWrite, RegReadOnly)):
            raise TypeError(f'size_props must be of {type(RegReadWrite)} or {type(RegReadOnly)} '
                            f'but got {type(parent_register)}')

        # pylint: disable=duplicate-code
        super().__init__(logger_handle=logger_handle,
                         size_props=size_props,
                         misc_props=misc_props,
                         parent_register=parent_register,
                         inst_name=inst_name,
                         field_type=field_type)
        # pylint: enable=duplicate-code

    def read(self) -> FieldType:
        """
        Reads the register that this field is located in and retries the field
        value applying the required masking and shifting

        Returns:
            field value

        """
        return self._decode_read_value(self.parent_register.read())

    @property
    def parent_register(self) -> ReadableRegister:
        """
        parent register the field is placed in
        """

        # this cast is OK because an explict typing check was done in the __init__
        return cast(ReadableRegister, self.parent)


class FieldWriteOnly(_FieldWriteOnlyFramework[FieldType], ABC):
    """
    class for a write only register field

    Args:
        parent_register: register within which the field resides
        size_props: object defining the msb, lsb, high bit, low bit and width
        logger_handle: name to be used logging messages associate with this
            object

    """
    __slots__: list[str] = []

    # pylint: disable-next=too-many-arguments
    def __init__(self, *,
                 parent_register: WritableRegister,
                 size_props: FieldSizeProps,
                 misc_props: FieldMiscProps,
                 logger_handle: str,
                 inst_name: str,
                 field_type:type[FieldType]):

        if not isinstance(parent_register, (RegReadWrite, RegWriteOnly)):
            raise TypeError(f'size_props must be of {type(RegReadWrite)} or {type(RegWriteOnly)} '
                            f'but got {type(parent_register)}')

        # pylint: disable=duplicate-code
        super().__init__(logger_handle=logger_handle,
                         size_props=size_props,
                         misc_props=misc_props,
                         parent_register=parent_register,
                         inst_name=inst_name,
                         field_type=field_type)
        # pylint: enable=duplicate-code

    def write(self, value: FieldType) -> None:
        """
        The behaviour of this method depends on whether the field is located in
        a readable register or not:

        If the register is readable, the method will perform a read-modify-write
        on the register updating the field with the value provided

        If the register is not writable all other field values will be written
        with zero.

        Args:
            value: field value to update to

        """
        encoded_value = self._encode_write_value(value)

        if (self.high == (self.register_data_width - 1)) and (self.low == 0):
            # special case where the field occupies the whole register,
            # there a straight write can be performed
            new_reg_value = encoded_value
        else:
            # do a read, modify write
            if isinstance(self.parent_register, RegReadWrite):
                reg_value = self.parent_register.read()
                masked_reg_value = reg_value & self.inverse_bitmask
                new_reg_value = masked_reg_value | encoded_value
            elif isinstance(self.parent_register, RegWriteOnly):
                new_reg_value = encoded_value
            else:
                raise TypeError('Unhandled parent type')

        self.parent_register.write(new_reg_value)

    @property
    def parent_register(self) -> WritableRegister:
        """
        parent register the field is placed in
        """

        # this cast is OK because an explict typing check was done in the __init__
        return cast(WritableRegister, self.parent)


class FieldReadWrite(FieldReadOnly[FieldType], FieldWriteOnly[FieldType], ABC):
    """
    class for a read/write register field

    Args:
        parent_register: register within which the field resides
        size_props: object defining the msb, lsb, high bit, low bit and width
        logger_handle: name to be used logging messages associate with this
            object

    """
    __slots__: list[str] = []

    # pylint: disable-next=too-many-arguments
    def __init__(self, *,
                 parent_register: RegReadWrite,
                 size_props: FieldSizeProps,
                 misc_props: FieldMiscProps,
                 logger_handle: str,
                 inst_name: str,
                 field_type:type[FieldType]):

        if not isinstance(parent_register, RegReadWrite):
            raise TypeError(f'parent_register must be of {type(RegReadWrite)} '
                            f'but got {type(parent_register)}')

        super().__init__(logger_handle=logger_handle,
                         size_props=size_props,
                         misc_props=misc_props,
                         parent_register=parent_register,
                         inst_name=inst_name,
                         field_type=field_type)

    @property
    def parent_register(self) -> RegReadWrite:
        """
        parent register the field is placed in
        """

        # this cast is OK because an explict typing check was done in the __init__
        return cast(RegReadWrite, self.parent)


class FieldEnumReadWrite(FieldReadWrite[FieldType], FieldEnum[FieldType], ABC):
    """
    class for a read/write register field with an enumerated value
    """
    __slots__: list[str] = []

    @property
    def parent_register(self) -> RegReadWrite:
        """
        parent register the field is placed in
        """

        # this cast is OK because an explict typing check was done in the __init__
        return cast(RegReadWrite, self.parent)


class FieldEnumReadOnly(FieldReadOnly[FieldType], FieldEnum[FieldType], ABC):
    """
    class for a read only register field with an enumerated value
    """
    __slots__: list[str] = []


class FieldEnumWriteOnly(FieldWriteOnly[FieldType], FieldEnum[FieldType], ABC):
    """
    class for a write only register field with an enumerated value
    """
    __slots__: list[str] = []
