library ieee;
context ieee.ieee_std_context;
use ieee.fixed_pkg.all;

-- Convenience types and utility functions used by the autogenerated regblock code
package reg_utils is

    type std_logic_array1 is array(natural range<>) of std_logic;
    type std_logic_array2 is array(natural range<>, natural range<>) of std_logic;
    type std_logic_array3 is array(natural range<>, natural range<>, natural range<>) of std_logic;
    type std_logic_array4 is array(natural range<>, natural range<>, natural range<>, natural range<>) of std_logic;
    type std_logic_array5 is array(natural range<>, natural range<>, natural range<>, natural range<>, natural range<>) of std_logic;

    type std_logic_vector_array1 is array(natural range<>) of std_logic_vector;
    type std_logic_vector_array2 is array(natural range<>, natural range<>) of std_logic_vector;
    type std_logic_vector_array3 is array(natural range<>, natural range<>, natural range<>) of std_logic_vector;
    type std_logic_vector_array4 is array(natural range<>, natural range<>, natural range<>, natural range<>) of std_logic_vector;
    type std_logic_vector_array5 is array(natural range<>, natural range<>, natural range<>, natural range<>, natural range<>) of std_logic_vector;

    -- reverse bits of the input vector
    function bitswap(vec: in std_logic_vector) return std_logic_vector;
    function bitswap(logic: in std_logic) return std_logic;

    -- Autogenerating VHDL when dealing with programmatically defined field widths
    -- can be challenging, especially when doing arithmetic. These conversion functions
    -- are overloaded with various input types, allow them to work regardless
    -- of the input type or width.
    function to_unsigned(vec: in std_logic_vector) return unsigned;
    function to_unsigned(logic: in std_logic) return unsigned;

    function to_signed(vec: in std_logic_vector) return signed;
    function to_signed(logic: in std_logic) return signed;

    function to_std_logic_vector(uns: in unsigned) return std_logic_vector;
    function to_std_logic_vector(sgnd: in signed) return std_logic_vector;
    function to_std_logic_vector(logic: in std_logic) return std_logic_vector;
    -- std_logic_vector variant provided by ieee.std_logic_1164
    -- ufixed and sfixed variants are provided by ieee.fixed_pkg

    function from_std_logic_vector(vec: in std_logic_vector; slv: in std_logic_vector) return std_logic_vector;
    function from_std_logic_vector(vec: in std_logic_vector; uns: in unsigned) return unsigned;
    function from_std_logic_vector(vec: in std_logic_vector; sgnd: in signed) return signed;
    function from_std_logic_vector(vec: in std_logic_vector; ufx: in ufixed) return ufixed;
    function from_std_logic_vector(vec: in std_logic_vector; sfx: in sfixed) return sfixed;

    function to_std_logic(bool: in boolean) return std_logic;
    function to_std_logic(logic: in std_logic) return std_logic;
    function to_std_logic(vec: in std_logic_vector(0 downto 0)) return std_logic;
    function to_std_logic(uns: in unsigned(0 downto 0)) return std_logic;
    function to_std_logic(sgnd: in signed(0 downto 0)) return std_logic;
    function to_std_logic(ufx: in ufixed(0 downto 0)) return std_logic;
    function to_std_logic(sfx: in sfixed(0 downto 0)) return std_logic;

    function from_std_logic(logic: in std_logic; lg: in std_logic) return std_logic;
    function from_std_logic(logic: in std_logic; uns: in unsigned) return unsigned;
    function from_std_logic(logic: in std_logic; sgnd: in signed) return signed;
    function from_std_logic(logic: in std_logic; ufx: in ufixed) return ufixed;
    function from_std_logic(logic: in std_logic; sfx: in sfixed) return sfixed;

    -- reduction OR for tools with poor VHDL 2008 support
    function or_reduce(vec: in std_logic_vector) return std_logic;
    function or_reduce(logic: in std_logic) return std_logic;

end package reg_utils;

package body reg_utils is

    function bitswap(vec: in std_logic_vector) return std_logic_vector is
        variable result: std_logic_vector(vec'RANGE);
        alias swapped: std_logic_vector(vec'REVERSE_RANGE) is vec;
    begin
        for i in swapped'RANGE loop
            result(i) := swapped(i);
        end loop;
        return result;
    end function;

    function bitswap(logic: in std_logic) return std_logic is
    begin
        return logic;
    end function;

    function to_unsigned(vec: in std_logic_vector) return unsigned is
    begin
        return unsigned(vec);
    end function;

    function to_unsigned(logic: in std_logic) return unsigned is
        variable result: unsigned(0 downto 0);
    begin
        result(0) := logic;
        return result;
    end function;

    function to_signed(vec: in std_logic_vector) return signed is
    begin
        return signed(vec);
    end function;

    function to_signed(logic: in std_logic) return signed is
        variable result: signed(0 downto 0);
    begin
        result(0) := logic;
        return result;
    end function;

    function to_std_logic_vector(uns: in unsigned) return std_logic_vector is
    begin
        return std_logic_vector(uns);
    end function;

    function to_std_logic_vector(sgnd: in signed) return std_logic_vector is
    begin
        return std_logic_vector(sgnd);
    end function;

    function to_std_logic_vector(logic: in std_logic) return std_logic_vector is
        variable result: std_logic_vector(0 downto 0);
    begin
        result(0) := logic;
        return result;
    end function;


    function from_std_logic_vector(vec: in std_logic_vector; slv: in std_logic_vector) return std_logic_vector is
    begin
        return vec;
    end function;

    function from_std_logic_vector(vec: in std_logic_vector; uns: in unsigned) return unsigned is
    begin
        return unsigned(vec);
    end function;

    function from_std_logic_vector(vec: in std_logic_vector; sgnd: in signed) return signed is
    begin
        return signed(vec);
    end function;

    function from_std_logic_vector(vec: in std_logic_vector; ufx: in ufixed) return ufixed is
    begin
        return ufixed(vec);
    end function;

    function from_std_logic_vector(vec: in std_logic_vector; sfx: in sfixed) return sfixed is
    begin
        return sfixed(vec);
    end function;


    function to_std_logic(bool: in boolean) return std_logic is
    begin
        if bool = TRUE then
            return '1';
        else
            return '0';
        end if;
    end function;

    function to_std_logic(logic: in std_logic) return std_logic is
    begin
        return logic;
    end function;

    function to_std_logic(vec: in std_logic_vector(0 downto 0)) return std_logic is
    begin
        return vec(0);
    end function;

    function to_std_logic(uns: in unsigned(0 downto 0)) return std_logic is
    begin
        return uns(0);
    end function;

    function to_std_logic(sgnd: in signed(0 downto 0)) return std_logic is
    begin
        return sgnd(0);
    end function;

    function to_std_logic(ufx: in ufixed(0 downto 0)) return std_logic is
    begin
        return ufx(0);
    end function;

    function to_std_logic(sfx: in sfixed(0 downto 0)) return std_logic is
    begin
        return sfx(0);
    end function;


    function from_std_logic(logic: in std_logic; lg: in std_logic) return std_logic is
    begin
        return logic;
    end function;

    function from_std_logic(logic: in std_logic; uns: in unsigned) return unsigned is
    begin
        return to_unsigned(logic);
    end function;

    function from_std_logic(logic: in std_logic; sgnd: in signed) return signed is
    begin
        return to_signed(logic);
    end function;

    function from_std_logic(logic: in std_logic; ufx: in ufixed) return ufixed is
    begin
        return ufixed(to_unsigned(logic));
    end function;

    function from_std_logic(logic: in std_logic; sfx: in sfixed) return sfixed is
    begin
        return sfixed(to_signed(logic));
    end function;


    function or_reduce(vec: in std_logic_vector) return std_logic is
        variable result: std_logic;
    begin
        result := '0';
        for i in vec'RANGE loop
            result := result or vec(i);
        end loop;
        return result;
    end function;

    function or_reduce(logic: in std_logic) return std_logic is
    begin
        return logic;
    end function;

end package body;